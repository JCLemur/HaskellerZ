<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"> 
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Simon Meier" />
  <meta name="date" content="HaskellerZ meetup - January 19th, 2012" />
  <title>A guided tour through the bytestring library</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
  </style>
  <style type="text/css">
body{margin:0;padding:0;width:100%;height:100%;color:black;background-color:white;font-family:"Gill Sans MT","Gill Sans",GillSans,sans-serif;font-size:14pt;}.hidden{display:none;visibility:hidden;}div.toolbar{position:fixed;z-index:200;top:auto;bottom:0;left:0;right:0;height:1.2em;text-align:right;padding-left:1em;padding-right:1em;font-size:60%;color:red;background:#f0f0f0;}div.background{display:none;}div.handout{margin-left:20px;margin-right:20px;}div.slide.titlepage{text-align:center;}div.slide.titlepage.h1{padding-top:40%;}div.slide{z-index:20;margin:0;padding-top:0;padding-bottom:0;padding-left:20px;padding-right:20px;border-width:0;clear:both;top:0;bottom:0;left:0;right:0;line-height:120%;background-color:transparent;}div.slide+div[class].slide{page-break-before:always;}div.slide h1{padding-left:0;padding-right:20pt;padding-top:4pt;padding-bottom:4pt;margin-top:0;margin-left:0;margin-right:60pt;margin-bottom:.5em;display:block;font-size:160%;line-height:1.2em;background:transparent;}div.toc{position:absolute;top:auto;bottom:4em;left:4em;right:auto;width:60%;max-width:30em;height:30em;border:solid thin black;padding:1em;background:#f0f0f0;color:black;z-index:300;overflow:auto;display:block;visibility:visible;}div.toc-heading{width:100%;border-bottom:solid 1px #b4b4b4;margin-bottom:1em;text-align:center;}pre{font-size:80%;font-weight:bold;line-height:120%;padding-top:.2em;padding-bottom:.2em;padding-left:1em;padding-right:1em;border-style:solid;border-left-width:1em;border-top-width:thin;border-right-width:thin;border-bottom-width:thin;border-color:#95ABD0;color:#00428C;background-color:#E4E5E7;}li pre{margin-left:0;}@media print{div.slide{display:block;visibility:visible;position:relative;border-top-style:solid;border-top-width:thin;border-top-color:black;}div.slide pre{font-size:60%;padding-left:.5em;}div.handout{display:block;visibility:visible;}}blockquote{font-style:italic;}img{background-color:transparent;}p.copyright{font-size:smaller;}.center{text-align:center;}.footnote{font-size:smaller;margin-left:2em;}a img{border-width:0;border-style:none;}a:visited{color:navy;}a:link{color:navy;}a:hover{color:red;text-decoration:underline;}a:active{color:red;text-decoration:underline;}a{text-decoration:none;}.navbar a:link{color:white;}.navbar a:visited{color:yellow;}.navbar a:active{color:red;}.navbar a:hover{color:red;}ul{list-style-type:square;}ul ul{list-style-type:disc;}ul ul ul{list-style-type:circle;}ul ul ul ul{list-style-type:disc;}li{margin-left:.5em;margin-top:.5em;}li li{font-size:85%;font-style:italic;}li li li{font-size:85%;font-style:normal;}div dt{margin-left:0;margin-top:1em;margin-bottom:.5em;font-weight:bold;}div dd{margin-left:2em;margin-bottom:.5em;}p,pre,ul,ol,blockquote,h2,h3,h4,h5,h6,dl,table{margin-left:1em;margin-right:1em;}p.subhead{font-weight:bold;margin-top:2em;}.smaller{font-size:smaller;}.bigger{font-size:130%;}td,th{padding:.2em;}ul{margin:.5em 1.5em .5em 1.5em;padding:0;}ol{margin:.5em 1.5em .5em 1.5em;padding:0;}ul{list-style-type:square;}ul ul{list-style-type:disc;}ul ul ul{list-style-type:circle;}ul ul ul ul{list-style-type:disc;}ul li{list-style:square;margin:.1em 0 .6em 0;padding:0;line-height:140%;}ol li{margin:.1em 0 .6em 1.5em;padding:0;line-height:140%;list-style-type:decimal;}li ul li{font-size:85%;font-style:italic;list-style-type:disc;background:transparent;padding:0;}li li ul li{font-size:85%;font-style:normal;list-style-type:circle;background:transparent;padding:0;}li li li ul li{list-style-type:disc;background:transparent;padding:0;}li ol li{list-style-type:decimal;}li li ol li{list-style-type:decimal;}ol.outline li:hover{cursor:pointer;}ol.outline li.nofold:hover{cursor:default;}ul.outline li:hover{cursor:pointer;}ul.outline li.nofold:hover{cursor:default;}ol.outline{list-style:decimal;}ol.outline ol{list-style-type:lower-alpha;}ol.outline li.nofold{padding:0 0 0 20px;background:transparent url(nofold-dim.gif) no-repeat 0 .5em;}ol.outline li.unfolded{padding:0 0 0 20px;background:transparent url(fold-dim.gif) no-repeat 0 .5em;}ol.outline li.folded{padding:0 0 0 20px;background:transparent url(unfold-dim.gif) no-repeat 0 .5em;}ol.outline li.unfolded:hover{padding:0 0 0 20px;background:transparent url(fold.gif) no-repeat 0 .5em;}ol.outline li.folded:hover{padding:0 0 0 20px;background:transparent url(unfold.gif) no-repeat 0 .5em;}ul.outline li.nofold{padding:0 0 0 20px;background:transparent url(nofold-dim.gif) no-repeat 0 .5em;}ul.outline li.unfolded{padding:0 0 0 20px;background:transparent url(fold-dim.gif) no-repeat 0 .5em;}ul.outline li.folded{padding:0 0 0 20px;background:transparent url(unfold-dim.gif) no-repeat 0 .5em;}ul.outline li.unfolded:hover{padding:0 0 0 20px;background:transparent url(fold.gif) no-repeat 0 .5em;}ul.outline li.folded:hover{padding:0 0 0 20px;background:transparent url(unfold.gif) no-repeat 0 .5em;}a.titleslide{font-weight:bold;font-style:italic;}
  </style>
  <script type="text/javascript" charset="utf-8">
var ns_pos=(typeof window.pageYOffset!="undefined");var khtml=((navigator.userAgent).indexOf("KHTML")>=0?true:false);var opera=((navigator.userAgent).indexOf("Opera")>=0?true:false);var ie=(typeof document.all!="undefined"&&!opera);var ie7=(!ns_pos&&navigator.userAgent.indexOf("MSIE 7")!=-1);var ie8=(!ns_pos&&navigator.userAgent.indexOf("MSIE 8")!=-1);var slidy_started=false;if(ie&&!ie8){document.write("<iframe id='historyFrame' src='javascript:\"<html></html>\"' height='1' width='1' style='position:absolute;left:-800px'></iframe>")}if(typeof beforePrint!="undefined"){window.onbeforeprint=beforePrint;window.onafterprint=afterPrint}if(ie){setTimeout(ieSlidyInit,100)}else{if(document.addEventListener){document.addEventListener("DOMContentLoaded",startup,false)}}function ieSlidyInit(){if(document.readyState=="complete"||document.readyState=="loaded"){startup()}else{setTimeout(ieSlidyInit,100)}}setTimeout(hideSlides,50);function hideSlides(){if(document.body){document.body.style.visibility="hidden"}else{setTimeout(hideSlides,50)}}var slidenum=0;var slides;var slideNumElement;var notes;var backgrounds;var toolbar;var title;var lastShown=null;var eos=null;var toc=null;var outline=null;var selectedTextLen;var viewAll=0;var wantToolbar=1;var mouseClickEnabled=true;var scrollhack=0;var key_wanted=false;var helpAnchor;var helpPage="http://www.w3.org/Talks/Tools/Slidy/help.html";var helpText="Navigate with mouse click, space bar, Cursor Left/Right, or Pg Up and Pg Dn. Use S and B to change font size.";var sizeIndex=0;var sizeAdjustment=0;var sizes=new Array("10pt","12pt","14pt","16pt","18pt","20pt","22pt","24pt","26pt","28pt","30pt","32pt");var okayForIncremental=incrementalElementList();var lastWidth=0;var lastHeight=0;var objects;var lang="en";var strings_es={slide:"pág.","help?":"Ayuda","contents?":"Índice","table of contents":"tabla de contenidos","Table of Contents":"Tabla de Contenidos","restart presentation":"Reiniciar presentación","restart?":"Inicio"};strings_es[helpText]="Utilice el ratón, barra espaciadora, teclas Izda/Dcha, o Re pág y Av pág. Use S y B para cambiar el tamaño de fuente.";var strings_ca={slide:"pàg..","help?":"Ajuda","contents?":"Índex","table of contents":"taula de continguts","Table of Contents":"Taula de Continguts","restart presentation":"Reiniciar presentació","restart?":"Inici"};strings_ca[helpText]="Utilitzi el ratolí, barra espaiadora, tecles Esq./Dta. o Re pàg y Av pàg. Usi S i B per canviar grandària de font.";var strings_nl={slide:"pagina","help?":"Help?","contents?":"Inhoud?","table of contents":"inhoudsopgave","Table of Contents":"Inhoudsopgave","restart presentation":"herstart presentatie","restart?":"Herstart?"};strings_nl[helpText]="Navigeer d.m.v. het muis, spatiebar, Links/Rechts toetsen, of PgUp en PgDn. Gebruik S en B om de karaktergrootte te veranderen.";var strings_de={slide:"Seite","help?":"Hilfe","contents?":"Übersicht","table of contents":"Inhaltsverzeichnis","Table of Contents":"Inhaltsverzeichnis","restart presentation":"Präsentation neu starten","restart?":"Neustart"};strings_de[helpText]="Benutzen Sie die Maus, Leerschlag, die Cursortasten links/rechts oder Page up/Page Down zum Wechseln der Seiten und S und B für die Schriftgrösse.";var strings_pl={slide:"slajd","help?":"pomoc?","contents?":"spis treści?","table of contents":"spis treści","Table of Contents":"Spis Treści","restart presentation":"Restartuj prezentację","restart?":"restart?"};strings_pl[helpText]="Zmieniaj slajdy klikając myszą, naciskając spację, strzałki lewo/prawolub PgUp / PgDn. Użyj klawiszy S i B, aby zmienić rozmiar czczionki.";var strings_fr={slide:"page","help?":"Aide","contents?":"Index","table of contents":"table des matières","Table of Contents":"Table des matières","restart presentation":"Recommencer l'exposé","restart?":"Début"};strings_fr[helpText]="Naviguez avec la souris, la barre d'espace, les flèches gauche/droite ou les touches Pg Up, Pg Dn. Utilisez les touches S et B pour modifier la taille de la police.";var strings_hu={slide:"oldal","help?":"segítség","contents?":"tartalom","table of contents":"tartalomjegyzék","Table of Contents":"Tartalomjegyzék","restart presentation":"bemutató újraindítása","restart?":"újraindítás"};strings_hu[helpText]="Az oldalak közti lépkedéshez kattintson az egérrel, vagy használja a szóköz, a bal, vagy a jobb nyíl, illetve a Page Down, Page Up billentyűket. Az S és a B billentyűkkel változtathatja a szöveg méretét.";var strings_it={slide:"pag.","help?":"Aiuto","contents?":"Indice","table of contents":"indice","Table of Contents":"Indice","restart presentation":"Ricominciare la presentazione","restart?":"Inizio"};strings_it[helpText]="Navigare con mouse, barra spazio, frecce sinistra/destra o PgUp e PgDn. Usare S e B per cambiare la dimensione dei caratteri.";var strings_el={slide:"σελίδα","help?":"βοήθεια;","contents?":"περιεχόμενα;","table of contents":"πίνακας περιεχομένων","Table of Contents":"Πίνακας Περιεχομένων","restart presentation":"επανεκκίνηση παρουσίασης","restart?":"επανεκκίνηση;"};strings_el[helpText]="Πλοηγηθείτε με το κλίκ του ποντικιού, το space, τα βέλη αριστερά/δεξιά, ή Page Up και Page Down. Χρησιμοποιήστε τα πλήκτρα S και B για να αλλάξετε το μέγεθος της γραμματοσειράς.";var strings_ja={slide:"スライド","help?":"ヘルプ","contents?":"目次","table of contents":"目次を表示","Table of Contents":"目次","restart presentation":"最初から再生","restart?":"最初から"};strings_ja[helpText]="マウス左クリック ・ スペース ・ 左右キー または Page Up ・ Page Downで操作， S ・ Bでフォントサイズ変更";var strings_zh={slide:"幻灯片","help?":"帮助?","contents?":"内容?","table of contents":"目录","Table of Contents":"目录","restart presentation":"重新启动展示","restart?":"重新启动?"};strings_zh[helpText]="用鼠标点击, 空格条, 左右箭头, Pg Up 和 Pg Dn 导航. 用 S, B 改变字体大小.";var strings_ru={slide:"слайд","help?":"помощь?","contents?":"содержание?","table of contents":"оглавление","Table of Contents":"Оглавление","restart presentation":"перезапустить презентацию","restart?":"перезапуск?"};strings_ru[helpText]="Перемещайтесь кликая мышкой, используя клавишу пробел, стрелкивлево/вправо или Pg Up и Pg Dn. Клавиши S и B меняют размер шрифта.";var strings_sv={slide:"sida","help?":"hjälp","contents?":"innehåll","table of contents":"innehållsförteckning","Table of Contents":"Innehållsförteckning","restart presentation":"visa presentationen från början","restart?":"börja om"};strings_sv[helpText]="Bläddra med ett klick med vänstra musknappen, mellanslagstangenten, vänster- och högerpiltangenterna eller tangenterna Pg Up, Pg Dn. Använd tangenterna S och B för att ändra textens storlek.";var localize={es:strings_es,ca:strings_ca,nl:strings_nl,de:strings_de,pl:strings_pl,fr:strings_fr,hu:strings_hu,it:strings_it,el:strings_el,jp:strings_ja,zh:strings_zh,ru:strings_ru,sv:strings_sv};function startup(){if(slidy_started){alert("already started");return}slidy_started=true;lang=document.body.parentNode.getAttribute("lang");if(!lang){lang=document.body.parentNode.getAttribute("xml:lang")}if(!lang){lang="en"}document.body.style.visibility="visible";title=document.title;toolbar=addToolbar();wrapImplicitSlides();slides=collectSlides();notes=collectNotes();objects=document.body.getElementsByTagName("object");backgrounds=collectBackgrounds();patchAnchors();slidenum=findSlideNumber(location.href);window.offscreenbuffering=true;sizeAdjustment=findSizeAdjust();hideImageToolbar();initOutliner();if(slides.length>0){var slide=slides[slidenum];slide.style.position="absolute";if(slidenum>0){setVisibilityAllIncremental("visible");lastShown=previousIncrementalItem(null);setEosStatus(true)}else{lastShown=null;setVisibilityAllIncremental("hidden");setEosStatus(!nextIncrementalItem(lastShown))}setLocation()}toc=tableOfContents();hideTableOfContents();document.onclick=mouseButtonClick;document.onmouseup=mouseButtonUp;document.onkeydown=keyDown;if(opera){document.onkeypress=keyPress}window.onresize=resized;window.onscroll=scrolled;window.onunload=unloaded;singleSlideView();setLocation();resized();if(ie7){setTimeout("ieHack()",100)}showToolbar();setInterval("checkLocation()",200)}String.prototype.localize=function(){if(this==""){return this}var s,lookup=localize[lang];if(lookup){s=lookup[this];if(s){return s}}var lg=lang.split("-");if(lg.length>1){lookup=localize[lg[0]];if(lookup){s=lookup[this];if(s){return s}}}return this};function hideImageToolbar(){if(!ns_pos){var images=document.getElementsByTagName("IMG");for(var i=0;i<images.length;++i){images[i].setAttribute("galleryimg","no")}}}function ieHack(){window.resizeBy(0,-1);window.resizeBy(0,1)}function unloaded(e){}function reload(e){if(!e){var e=window.event}hideBackgrounds();setTimeout("document.reload();",100);stopPropagation(e);e.cancel=true;e.returnValue=false;return false}function isKHTML(){var agent=navigator.userAgent;return(agent.indexOf("KHTML")>=0?true:false)}function resized(){var width=0;if(typeof(window.innerWidth)=="number"){width=window.innerWidth}else{if(document.documentElement&&document.documentElement.clientWidth){width=document.documentElement.clientWidth}else{if(document.body&&document.body.clientWidth){width=document.body.clientWidth}}}var height=0;if(typeof(window.innerHeight)=="number"){height=window.innerHeight}else{if(document.documentElement&&document.documentElement.clientHeight){height=document.documentElement.clientHeight}else{if(document.body&&document.body.clientHeight){height=document.body.clientHeight}}}if(height&&(width/height>1.05*1024/768)){width=height*1024/768}if(width!=lastWidth||height!=lastHeight){if(width>=1100){sizeIndex=5}else{if(width>=1000){sizeIndex=4}else{if(width>=800){sizeIndex=3}else{if(width>=600){sizeIndex=2}else{if(width){sizeIndex=0}}}}}if(0<=sizeIndex+sizeAdjustment&&sizeIndex+sizeAdjustment<sizes.length){sizeIndex=sizeIndex+sizeAdjustment}adjustObjectDimensions(width,height);document.body.style.fontSize=sizes[sizeIndex];lastWidth=width;lastHeight=height;var slide=slides[slidenum];hideSlide(slide);showSlide(slide);refreshToolbar(200)}}function scrolled(){if(toolbar&&!ns_pos&&!ie7){hackoffset=scrollXOffset();toolbar.style.display="none";if(scrollhack==0&&!viewAll){setTimeout(showToolbar,1000);scrollhack=1}}}function refreshToolbar(interval){if(!ns_pos&&!ie7){hideToolbar();setTimeout(showToolbar,interval)}}function showToolbar(){if(wantToolbar){if(!ns_pos){var xoffset=scrollXOffset();toolbar.style.left=xoffset;toolbar.style.right=xoffset;toolbar.style.bottom=0}toolbar.style.display="block";toolbar.style.visibility="visible"}scrollhack=0;try{if(!opera){helpAnchor.focus()}}catch(e){}}function hideToolbar(){toolbar.style.display="none";toolbar.style.visibility="hidden";window.focus()}function toggleToolbar(){if(!viewAll){if(toolbar.style.display=="none"){toolbar.style.display="block";toolbar.style.visibility="visible";wantToolbar=1}else{toolbar.style.display="none";toolbar.style.visibility="hidden";wantToolbar=0}}}function scrollXOffset(){if(window.pageXOffset){return self.pageXOffset}if(document.documentElement&&document.documentElement.scrollLeft){return document.documentElement.scrollLeft}if(document.body){return document.body.scrollLeft}return 0}function scrollYOffset(){if(window.pageYOffset){return self.pageYOffset}if(document.documentElement&&document.documentElement.scrollTop){return document.documentElement.scrollTop}if(document.body){return document.body.scrollTop}return 0}function optimizeFontSize(){var slide=slides[slidenum];var dh=slide.scrollHeight;var wh=getWindowHeight();var u=100*dh/wh;alert("window utilization = "+u+"% (doc "+dh+" win "+wh+")")}function getDocHeight(doc){if(!doc){doc=document}if(doc&&doc.body&&doc.body.offsetHeight){return doc.body.offsetHeight}if(doc&&doc.body&&doc.body.scrollHeight){return doc.body.scrollHeight}alert("couldn't determine document height")}function getWindowHeight(){if(typeof(window.innerHeight)=="number"){return window.innerHeight}if(document.documentElement&&document.documentElement.clientHeight){return document.documentElement.clientHeight}if(document.body&&document.body.clientHeight){return document.body.clientHeight}}function documentHeight(){var sh,oh;sh=document.body.scrollHeight;oh=document.body.offsetHeight;if(sh&&oh){return(sh>oh?sh:oh)}return 0}function smaller(){if(sizeIndex>0){--sizeIndex}toolbar.style.display="none";document.body.style.fontSize=sizes[sizeIndex];var slide=slides[slidenum];hideSlide(slide);showSlide(slide);setTimeout(showToolbar,300)}function bigger(){if(sizeIndex<sizes.length-1){++sizeIndex}toolbar.style.display="none";document.body.style.fontSize=sizes[sizeIndex];var slide=slides[slidenum];hideSlide(slide);showSlide(slide);setTimeout(showToolbar,300)}function adjustObjectDimensions(width,height){for(var i=0;i<objects.length;i++){var obj=objects[i];var mimeType=obj.getAttribute("type");if(mimeType=="image/svg+xml"||mimeType=="application/x-shockwave-flash"){if(!obj.initialWidth){obj.initialWidth=obj.getAttribute("width")}if(!obj.initialHeight){obj.initialHeight=obj.getAttribute("height")}if(obj.initialWidth&&obj.initialWidth.charAt(obj.initialWidth.length-1)=="%"){var w=parseInt(obj.initialWidth.slice(0,obj.initialWidth.length-1));var newW=width*(w/100);obj.setAttribute("width",newW)}if(obj.initialHeight&&obj.initialHeight.charAt(obj.initialHeight.length-1)=="%"){var h=parseInt(obj.initialHeight.slice(0,obj.initialHeight.length-1));var newH=height*(h/100);obj.setAttribute("height",newH)}}}}function cancel(event){if(event){event.cancel=true;event.returnValue=false;if(event.preventDefault){event.preventDefault()}}return false}function keyDown(event){var key;if(!event){var event=window.event}key_wanted=false;if(window.event){key=window.event.keyCode}else{if(event.which){key=event.which}else{return true}}if(!key){return true}if(event.ctrlKey||event.altKey||event.metaKey){return true}if(isShownToc()&&key!=9&&key!=16&&key!=38&&key!=40){hideTableOfContents();if(key==27||key==84||key==67){return cancel(event)}}key_wanted=true;if(key==34){if(viewAll){return true}nextSlide(false);return cancel(event)}else{if(key==33){if(viewAll){return true}previousSlide(false);return cancel(event)}else{if(key==32){nextSlide(true);return cancel(event)}else{if(key==37){previousSlide(!event.shiftKey);return cancel(event)}else{if(key==36){firstSlide();return cancel(event)}else{if(key==35){lastSlide();return cancel(event)}else{if(key==39){nextSlide(!event.shiftKey);return cancel(event)}else{if(key==13){if(outline){if(outline.visible){fold(outline)}else{unfold(outline)}return cancel(event)}}else{if(key==188){smaller();return cancel(event)}else{if(key==190){bigger();return cancel(event)}else{if(key==189||key==109){smaller();return cancel(event)}else{if(key==187||key==191||key==107){bigger();return cancel(event)}else{if(key==83){smaller();return cancel(event)}else{if(key==66){bigger();return cancel(event)}else{if(key==90){lastSlide();return cancel(event)}else{if(key==70){toggleToolbar();return cancel(event)}else{if(key==65){toggleView();return cancel(event)}else{if(key==75){mouseClickEnabled=!mouseClickEnabled;alert((mouseClickEnabled?"enabled":"disabled")+" mouse click advance");return cancel(event)}else{if(key==84||key==67){if(toc){showTableOfContents()}return cancel(event)}else{if(key==72){window.location=helpPage;return cancel(event)}}}}}}}}}}}}}}}}}}}}key_wanted=false;return true}function keyPress(event){if(!event){event=window.event}return key_wanted?cancel(event):true}function mouseButtonUp(e){selectedTextLen=getSelectedText().length}function mouseButtonClick(e){var rightclick=false;var leftclick=false;var middleclick=false;var target;if(!e){var e=window.event}if(e.target){target=e.target}else{if(e.srcElement){target=e.srcElement}}if(target.nodeType==3){target=target.parentNode}if(e.which){leftclick=(e.which==1);middleclick=(e.which==2);rightclick=(e.which==3)}else{if(e.button){if(e.button==4){middleclick=true}rightclick=(e.button==2)}else{leftclick=true}}if(selectedTextLen>0){stopPropagation(e);e.cancel=true;e.returnValue=false;return false}hideTableOfContents();if(mouseClickEnabled&&leftclick&&target.nodeName!="EMBED"&&target.nodeName!="OBJECT"&&target.nodeName!="VIDEO"&&target.nodeName!="INPUT"&&target.nodeName!="TEXTAREA"&&target.nodeName!="SELECT"&&target.nodeName!="OPTION"){nextSlide(true);stopPropagation(e);e.cancel=true;e.returnValue=false}}function previousSlide(incremental){if(!viewAll){var slide;if((incremental||slidenum==0)&&lastShown!=null){lastShown=hidePreviousItem(lastShown);setEosStatus(false)}else{if(slidenum>0){slide=slides[slidenum];hideSlide(slide);slidenum=slidenum-1;slide=slides[slidenum];setVisibilityAllIncremental("visible");lastShown=previousIncrementalItem(null);setEosStatus(true);showSlide(slide)}}setLocation();if(!ns_pos){refreshToolbar(200)}}}function nextSlide(incremental){if(!viewAll){var slide,last=lastShown;if(incremental||slidenum==slides.length-1){lastShown=revealNextItem(lastShown)}if((!incremental||lastShown==null)&&slidenum<slides.length-1){slide=slides[slidenum];hideSlide(slide);slidenum=slidenum+1;slide=slides[slidenum];lastShown=null;setVisibilityAllIncremental("hidden");showSlide(slide)}else{if(!lastShown){if(last&&incremental){lastShown=last}}}setLocation();setEosStatus(!nextIncrementalItem(lastShown));if(!ns_pos){refreshToolbar(200)}}}function firstSlide(){if(!viewAll){var slide;if(slidenum!=0){slide=slides[slidenum];hideSlide(slide);slidenum=0;slide=slides[slidenum];lastShown=null;setVisibilityAllIncremental("hidden");showSlide(slide)}setEosStatus(!nextIncrementalItem(lastShown));setLocation()}}function lastSlide(){if(!viewAll){var slide;lastShown=null;if(lastShown==null&&slidenum<slides.length-1){slide=slides[slidenum];hideSlide(slide);slidenum=slides.length-1;slide=slides[slidenum];setVisibilityAllIncremental("visible");lastShown=previousIncrementalItem(null);showSlide(slide)}else{setVisibilityAllIncremental("visible");lastShown=previousIncrementalItem(null)}setEosStatus(true);setLocation()}}function gotoSlide(num){var slide=slides[slidenum];hideSlide(slide);slidenum=num;slide=slides[slidenum];lastShown=null;setVisibilityAllIncremental("hidden");setEosStatus(!nextIncrementalItem(lastShown));document.title=title+" ("+(slidenum+1)+")";showSlide(slide);showSlideNumber()}function setEosStatus(state){if(eos){eos.style.color=(state?"rgb(240,240,240)":"red")}}function showSlide(slide){syncBackground(slide);window.scrollTo(0,0);slide.style.visibility="visible";slide.style.display="block"}function hideSlide(slide){slide.style.visibility="hidden";slide.style.display="none"}function beforePrint(){showAllSlides();hideToolbar()}function afterPrint(){if(!viewAll){singleSlideView();showToolbar()}}function printSlides(){beforePrint();window.print();afterPrint()}function toggleView(){if(viewAll){singleSlideView();showToolbar();viewAll=0}else{showAllSlides();hideToolbar();viewAll=1}}function showAllSlides(){var slide;for(var i=0;i<slides.length;++i){slide=slides[i];slide.style.position="relative";slide.style.borderTopStyle="solid";slide.style.borderTopWidth="thin";slide.style.borderTopColor="black";try{if(i==0){slide.style.pageBreakBefore="avoid"}else{slide.style.pageBreakBefore="always"}}catch(e){}setVisibilityAllIncremental("visible");showSlide(slide)}var note;for(var i=0;i<notes.length;++i){showSlide(notes[i])}hideBackgrounds()}function singleSlideView(){var slide;for(var i=0;i<slides.length;++i){slide=slides[i];slide.style.position="absolute";if(i==slidenum){slide.style.borderStyle="none";showSlide(slide)}else{slide.style.borderStyle="none";hideSlide(slide)}}setVisibilityAllIncremental("visible");lastShown=previousIncrementalItem(null);var note;for(var i=0;i<notes.length;++i){hideSlide(notes[i])}}function hasToken(str,token){if(str){var pattern=/\w+/g;var result=str.match(pattern);for(var i=0;i<result.length;i++){if(result[i]==token){return true}}}return false}function getClassList(element){if(typeof element.className!="undefined"){return element.className}var clsname=(ns_pos||ie8)?"class":"className";return element.getAttribute(clsname)}function hasClass(element,name){var regexp=new RegExp("(^| )"+name+"W*");if(typeof element.className!="undefined"){return regexp.test(element.className)}var clsname=(ns_pos||ie8)?"class":"className";return regexp.test(element.getAttribute(clsname))}function removeClass(element,name){var regexp=new RegExp("(^| )"+name+"W*");var clsval="";if(typeof element.className!="undefined"){clsval=element.className;if(clsval){clsval=clsval.replace(regexp,"");element.className=clsval}}else{var clsname=(ns_pos||ie8)?"class":"className";clsval=element.getAttribute(clsname);if(clsval){clsval=clsval.replace(regexp,"");element.setAttribute(clsname,clsval)}}}function addClass(element,name){if(!hasClass(element,name)){if(typeof element.className!="undefined"){element.className+=" "+name}else{var clsname=(ns_pos||ie8)?"class":"className";var clsval=element.getAttribute(clsname);clsval=clsval?clsval+" "+name:name;element.setAttribute(clsname,clsval)}}}function wrapImplicitSlides(){var i,heading,node,next,div;var headings=document.getElementsByTagName("h1");if(!headings){return}for(i=0;i<headings.length;++i){heading=headings[i];if(heading.parentNode!=document.body){continue}node=heading.nextSibling;div=document.createElement("div");addClass(div,"slide");document.body.replaceChild(div,heading);div.appendChild(heading);while(node){if(node.nodeType==1&&(node.nodeName=="H1"||node.nodeName=="h1"||node.nodeName=="DIV"||node.nodeName=="div")){break}next=node.nextSibling;node=document.body.removeChild(node);div.appendChild(node);node=next}}}function collectSlides(){var slides=new Array();var divs=document.body.getElementsByTagName("div");for(var i=0;i<divs.length;++i){div=divs.item(i);if(hasClass(div,"slide")){slides[slides.length]=div;div.style.display="none";div.style.visibility="hidden";var node1=document.createElement("br");div.appendChild(node1);var node2=document.createElement("br");div.appendChild(node2)}else{if(hasClass(div,"background")){div.style.display="block"}}}return slides}function collectNotes(){var notes=new Array();var divs=document.body.getElementsByTagName("div");for(var i=0;i<divs.length;++i){div=divs.item(i);if(hasClass(div,"handout")){notes[notes.length]=div;div.style.display="none";div.style.visibility="hidden"}}return notes}function collectBackgrounds(){var backgrounds=new Array();var divs=document.body.getElementsByTagName("div");for(var i=0;i<divs.length;++i){div=divs.item(i);if(hasClass(div,"background")){backgrounds[backgrounds.length]=div;if(getClassList(div)!="background"){div.style.display="none";div.style.visibility="hidden"}}}return backgrounds}function syncBackground(slide){var background;var bgColor;if(slide.currentStyle){bgColor=slide.currentStyle.backgroundColor}else{if(document.defaultView){var styles=document.defaultView.getComputedStyle(slide,null);if(styles){bgColor=styles.getPropertyValue("background-color")}else{bgColor="transparent"}}else{bgColor=="transparent"}}if(bgColor=="transparent"){var slideClass=getClassList(slide);for(var i=0;i<backgrounds.length;i++){background=backgrounds[i];var bgClass=getClassList(background);if(matchingBackground(slideClass,bgClass)){background.style.display="block";background.style.visibility="visible"}else{background.style.display="none";background.style.visibility="hidden"}}}else{hideBackgrounds()}}function hideBackgrounds(){for(var i=0;i<backgrounds.length;i++){background=backgrounds[i];background.style.display="none";background.style.visibility="hidden"}}function matchingBackground(slideClass,bgClass){if(bgClass=="background"){return true}var pattern=/\w+/g;var result=slideClass.match(pattern);for(var i=0;i<result.length;i++){if(hasToken(bgClass,result[i])){return true}}return false}function nextNode(root,node){if(node==null){return root.firstChild}if(node.firstChild){return node.firstChild}if(node.nextSibling){return node.nextSibling}for(;;){node=node.parentNode;if(!node||node==root){break}if(node&&node.nextSibling){return node.nextSibling}}return null}function previousNode(root,node){if(node==null){node=root.lastChild;if(node){while(node.lastChild){node=node.lastChild}}return node}if(node.previousSibling){node=node.previousSibling;while(node.lastChild){node=node.lastChild}return node}if(node.parentNode!=root){return node.parentNode}return null}function incrementalElementList(){var inclist=new Array();inclist.P=true;inclist.PRE=true;inclist.LI=true;inclist.BLOCKQUOTE=true;inclist.DT=true;inclist.DD=true;inclist.H2=true;inclist.H3=true;inclist.H4=true;inclist.H5=true;inclist.H6=true;inclist.SPAN=true;inclist.ADDRESS=true;inclist.TABLE=true;inclist.TR=true;inclist.TH=true;inclist.TD=true;inclist.IMG=true;inclist.OBJECT=true;return inclist}function nextIncrementalItem(node){var slide=slides[slidenum];for(;;){node=nextNode(slide,node);if(node==null||node.parentNode==null){break}if(node.nodeType==1){if(node.nodeName=="BR"){continue}if(hasClass(node,"incremental")&&okayForIncremental[node.nodeName]){return node}if(hasClass(node.parentNode,"incremental")&&!hasClass(node,"non-incremental")){return node}}}return node}function previousIncrementalItem(node){var slide=slides[slidenum];for(;;){node=previousNode(slide,node);if(node==null||node.parentNode==null){break}if(node.nodeType==1){if(node.nodeName=="BR"){continue}if(hasClass(node,"incremental")&&okayForIncremental[node.nodeName]){return node}if(hasClass(node.parentNode,"incremental")&&!hasClass(node,"non-incremental")){return node}}}return node}function setVisibilityAllIncremental(value){var node=nextIncrementalItem(null);while(node){node.style.visibility=value;node=nextIncrementalItem(node)}}function revealNextItem(node){node=nextIncrementalItem(node);if(node&&node.nodeType==1){node.style.visibility="visible"}return node}function hidePreviousItem(node){if(node&&node.nodeType==1){node.style.visibility="hidden"}return previousIncrementalItem(node)}function patchAnchors(){var anchors=document.body.getElementsByTagName("a");for(var i=0;i<anchors.length;++i){anchors[i].onclick=clickedAnchor}}function clickedAnchor(e){if(!e){var e=window.event}if(pageAddress(this.href)==pageAddress(location.href)){var newslidenum=findSlideNumber(this.href);if(newslidenum!=slidenum){slide=slides[slidenum];hideSlide(slide);slidenum=newslidenum;slide=slides[slidenum];showSlide(slide);setLocation()}}else{if(this.target==null){location.href=this.href}}this.blur();stopPropagation(e)}function pageAddress(uri){var i=uri.indexOf("#");if(i<0){i=uri.indexOf("%23")}if(i<0){return uri}return uri.substr(0,i)}function showSlideNumber(){slideNumElement.innerHTML="slide".localize()+" "+(slidenum+1)+"/"+slides.length}function checkLocation(){var hash=location.hash;if(slidenum>0&&(hash==""||hash=="#")){gotoSlide(0)}else{if(hash.length>2&&hash!="#("+(slidenum+1)+")"){var num=parseInt(location.hash.substr(2));if(!isNaN(num)){gotoSlide(num-1)}}}}function setLocation(){var uri=pageAddress(location.href);var hash="#("+(slidenum+1)+")";if(slidenum>=0){uri=uri+hash}if(ie&&!ie8){pushHash(hash)}if(uri!=location.href){location.href=uri}if(khtml){hash="("+(slidenum+1)+")"}if(!ie&&location.hash!=hash&&location.hash!=""){location.hash=hash}document.title=title+" ("+(slidenum+1)+")";showSlideNumber()}function onFrameLoaded(hash){location.hash=hash;var uri=pageAddress(location.href);location.href=uri+hash}function pushHash(hash){if(hash==""){hash="#(1)"}window.location.hash=hash;var doc=document.getElementById("historyFrame").contentWindow.document;doc.open("javascript:'<html></html>'");doc.write('<html><head><script type="text/javascript">parent.onFrameLoaded(\''+(hash)+"');<\/script></head><body>hello mum</body></html>");doc.close()}function findSlideNumber(uri){var i=uri.indexOf("#");if(i<0){return 0}var anchor=unescape(uri.substr(i+1));var target=document.getElementById(anchor);if(!target){var re=/\((\d)+\)/;if(anchor.match(re)){var num=parseInt(anchor.substring(1,anchor.length-1));if(num>slides.length){num=1}if(--num<0){num=0}return num}re=/\[(\d)+\]/;if(anchor.match(re)){var num=parseInt(anchor.substring(1,anchor.length-1));if(num>slides.length){num=1}if(--num<0){num=0}return num}return 0}while(true){if(target.nodeName.toLowerCase()=="div"&&hasClass(target,"slide")){break}target=target.parentNode;if(!target){return 0}}for(i=0;i<slides.length;++i){if(slides[i]==target){return i}}return 0}function slideName(index){var name=null;var slide=slides[index];var heading=findHeading(slide);if(heading){name=extractText(heading)}if(!name){name=title+"("+(index+1)+")"}name.replace(/\&/g,"&amp;");name.replace(/\</g,"&lt;");name.replace(/\>/g,"&gt;");return name}function findHeading(node){if(!node||node.nodeType!=1){return null}if(node.nodeName=="H1"||node.nodeName=="h1"){return node}var child=node.firstChild;while(child){node=findHeading(child);if(node){return node}child=child.nextSibling}return null}function extractText(node){if(!node){return""}if(node.nodeType==3){return node.nodeValue}if(node.nodeType==1){node=node.firstChild;var text="";while(node){text=text+extractText(node);node=node.nextSibling}return text}return""}function findCopyright(){var name,content;var meta=document.getElementsByTagName("meta");for(var i=0;i<meta.length;++i){name=meta[i].getAttribute("name");content=meta[i].getAttribute("content");if(name=="copyright"){return content}}return null}function findSizeAdjust(){var name,content,offset;var meta=document.getElementsByTagName("meta");for(var i=0;i<meta.length;++i){name=meta[i].getAttribute("name");content=meta[i].getAttribute("content");if(name=="font-size-adjustment"){return 1*content}}return 1}function addToolbar(){var slideCounter,page;var toolbar=createElement("div");toolbar.setAttribute("class","toolbar");if(ns_pos){var right=document.createElement("div");right.setAttribute("style","float: right; text-align: right");slideCounter=document.createElement("div");slideCounter.innerHTML="slide".localize()+" n/m";right.appendChild(slideCounter);toolbar.appendChild(right);var left=document.createElement("div");left.setAttribute("style","text-align: left");eos=document.createElement("span");eos.innerHTML="* ";left.appendChild(eos);var help=document.createElement("a");help.setAttribute("href",helpPage);help.setAttribute("title",helpText.localize());help.innerHTML="help?".localize();left.appendChild(help);helpAnchor=help;var gap1=document.createTextNode(" ");left.appendChild(gap1);var contents=document.createElement("a");contents.setAttribute("href","javascript:toggleTableOfContents()");contents.setAttribute("title","table of contents".localize());contents.innerHTML="contents?".localize();left.appendChild(contents);var gap2=document.createTextNode(" ");left.appendChild(gap2);var start=document.createElement("a");start.setAttribute("href","javascript:firstSlide()");start.setAttribute("title","restart presentation".localize());start.innerHTML="restart?".localize();left.appendChild(start);var copyright=findCopyright();if(copyright){var span=document.createElement("span");span.innerHTML=copyright;span.style.color="black";span.style.marginLeft="4em";left.appendChild(span)}toolbar.appendChild(left)}else{toolbar.style.position=(ie7?"fixed":"absolute");toolbar.style.zIndex="200";toolbar.style.width="99.9%";toolbar.style.height="1.2em";toolbar.style.top="auto";toolbar.style.bottom="0";toolbar.style.left="0";toolbar.style.right="0";toolbar.style.textAlign="left";toolbar.style.fontSize="60%";toolbar.style.color="red";toolbar.borderWidth=0;toolbar.className="toolbar";toolbar.style.background="rgb(240,240,240)";var sp=document.createElement("span");sp.innerHTML="&nbsp;&nbsp;*&nbsp;";toolbar.appendChild(sp);eos=sp;var help=document.createElement("a");help.setAttribute("href",helpPage);help.setAttribute("title",helpText.localize());help.innerHTML="help?".localize();toolbar.appendChild(help);helpAnchor=help;var gap1=document.createTextNode(" ");toolbar.appendChild(gap1);var contents=document.createElement("a");contents.setAttribute("href","javascript:toggleTableOfContents()");contents.setAttribute("title","table of contents".localize());contents.innerHTML="contents?".localize();toolbar.appendChild(contents);var gap2=document.createTextNode(" ");toolbar.appendChild(gap2);var start=document.createElement("a");start.setAttribute("href","javascript:firstSlide()");start.setAttribute("title","restart presentation".localize());start.innerHTML="restart?".localize();toolbar.appendChild(start);var copyright=findCopyright();if(copyright){var span=document.createElement("span");span.innerHTML=copyright;span.style.color="black";span.style.marginLeft="2em";toolbar.appendChild(span)}slideCounter=document.createElement("div");slideCounter.style.position="absolute";slideCounter.style.width="auto";slideCounter.style.height="1.2em";slideCounter.style.top="auto";slideCounter.style.bottom=0;slideCounter.style.right="0";slideCounter.style.textAlign="right";slideCounter.style.color="red";slideCounter.style.background="rgb(240,240,240)";slideCounter.innerHTML="slide".localize()+" n/m";toolbar.appendChild(slideCounter)}toolbar.onclick=stopPropagation;document.body.appendChild(toolbar);slideNumElement=slideCounter;setEosStatus(false);return toolbar}function isShownToc(){if(toc&&toc.style.visible=="visible"){return true}return false}function showTableOfContents(){if(toc){if(toc.style.visibility!="visible"){toc.style.visibility="visible";toc.style.display="block";toc.focus();if(ie7&&slidenum==0){setTimeout("ieHack()",100)}}else{hideTableOfContents()}}}function hideTableOfContents(){if(toc&&toc.style.visibility!="hidden"){toc.style.visibility="hidden";toc.style.display="none";try{if(!opera){helpAnchor.focus()}}catch(e){}}}function toggleTableOfContents(){if(toc){if(toc.style.visible!="visible"){showTableOfContents()}else{hideTableOfContents()}}}function gotoEntry(e){var target;if(!e){var e=window.event}if(e.target){target=e.target}else{if(e.srcElement){target=e.srcElement}}if(target.nodeType==3){target=target.parentNode}if(target&&target.nodeType==1){var uri=target.getAttribute("href");if(uri){var slide=slides[slidenum];hideSlide(slide);slidenum=findSlideNumber(uri);slide=slides[slidenum];lastShown=null;setLocation();setVisibilityAllIncremental("hidden");setEosStatus(!nextIncrementalItem(lastShown));showSlide(slide);try{if(!opera){helpAnchor.focus()}}catch(e){}}}hideTableOfContents(e);if(ie7){ieHack()}stopPropagation(e);return cancel(e)}function gotoTocEntry(event){var key;if(!event){var event=window.event}if(window.event){key=window.event.keyCode}else{if(event.which){key=event.which}else{return true}}if(!key){return true}if(event.ctrlKey||event.altKey){return true}if(key==13){var uri=this.getAttribute("href");if(uri){var slide=slides[slidenum];hideSlide(slide);slidenum=findSlideNumber(uri);slide=slides[slidenum];lastShown=null;setLocation();setVisibilityAllIncremental("hidden");setEosStatus(!nextIncrementalItem(lastShown));showSlide(slide);try{if(!opera){helpAnchor.focus()}}catch(e){}}hideTableOfContents();if(ie7){ieHack()}return cancel(event)}if(key==40&&this.next){this.next.focus();return cancel(event)}if(key==38&&this.previous){this.previous.focus();return cancel(event)}return true}function isTitleSlide(slide){return hasClass(slide,"title")}function tableOfContents(){var toc=document.createElement("div");addClass(toc,"toc");var heading=document.createElement("div");addClass(heading,"toc-heading");heading.innerHTML="Table of Contents".localize();heading.style.textAlign="center";heading.style.width="100%";heading.style.margin="0";heading.style.marginBottom="1em";heading.style.borderBottomStyle="solid";heading.style.borderBottomColor="rgb(180,180,180)";heading.style.borderBottomWidth="1px";toc.appendChild(heading);var previous=null;for(var i=0;i<slides.length;++i){var title=hasClass(slides[i],"title");var num=document.createTextNode((i+1)+". ");toc.appendChild(num);var a=document.createElement("a");a.setAttribute("href","#("+(i+1)+")");if(title){addClass(a,"titleslide")}var name=document.createTextNode(slideName(i));a.appendChild(name);a.onclick=gotoEntry;a.onkeydown=gotoTocEntry;a.previous=previous;if(previous){previous.next=a}toc.appendChild(a);if(i==0){toc.first=a}if(i<slides.length-1){var br=document.createElement("br");toc.appendChild(br)}previous=a}toc.focus=function(){if(this.first){this.first.focus()}};toc.onmouseup=mouseButtonUp;toc.onclick=function(e){e||(e=window.event);if(selectedTextLen<=0){hideTableOfContents()}stopPropagation(e);if(e.cancel!=undefined){e.cancel=true}if(e.returnValue!=undefined){e.returnValue=false}return false};toc.style.position="absolute";toc.style.zIndex="300";toc.style.width="60%";toc.style.maxWidth="30em";toc.style.height="30em";toc.style.overflow="auto";toc.style.top="auto";toc.style.right="auto";toc.style.left="4em";toc.style.bottom="4em";toc.style.padding="1em";toc.style.background="rgb(240,240,240)";toc.style.borderStyle="solid";toc.style.borderWidth="2px";toc.style.fontSize="60%";document.body.insertBefore(toc,document.body.firstChild);return toc}function replaceByNonBreakingSpace(str){for(var i=0;i<str.length;++i){str[i]=160}}function initOutliner(){var items=document.getElementsByTagName("LI");for(var i=0;i<items.length;++i){var target=items[i];if(!hasClass(target.parentNode,"outline")){continue}target.onclick=outlineClick;if(!ns_pos){target.onmouseover=hoverOutline;target.onmouseout=unhoverOutline}if(foldable(target)){target.foldable=true;target.onfocus=function(){outline=this};target.onblur=function(){outline=null};if(!target.getAttribute("tabindex")){target.setAttribute("tabindex","0")}if(hasClass(target,"expand")){unfold(target)}else{fold(target)}}else{addClass(target,"nofold");target.visible=true;target.foldable=false}}}function foldable(item){if(!item||item.nodeType!=1){return false}var node=item.firstChild;while(node){if(node.nodeType==1&&isBlock(node)){return true}node=node.nextSibling}return false}function fold(item){if(item){removeClass(item,"unfolded");addClass(item,"folded")}var node=item?item.firstChild:null;while(node){if(node.nodeType==1&&isBlock(node)){node.display=getElementStyle(node,"display","display");node.style.display="none";node.style.visibility="hidden"}node=node.nextSibling}item.visible=false}function unfold(item){if(item){addClass(item,"unfolded");removeClass(item,"folded")}var node=item?item.firstChild:null;while(node){if(node.nodeType==1&&isBlock(node)){node.style.display=(node.display?node.display:"block");node.style.visibility="visible"}node=node.nextSibling}item.visible=true}function outlineClick(e){var rightclick=false;var target;if(!e){var e=window.event}if(e.target){target=e.target}else{if(e.srcElement){target=e.srcElement}}if(target.nodeType==3){target=target.parentNode}while(target&&target.visible==undefined){target=target.parentNode}if(!target){return true}if(e.which){rightclick=(e.which==3)}else{if(e.button){rightclick=(e.button==2)}}if(!rightclick&&target.visible!=undefined){if(target.foldable){if(target.visible){fold(target)}else{unfold(target)}}stopPropagation(e);e.cancel=true;e.returnValue=false}return false}function hoverOutline(e){var target;if(!e){var e=window.event}if(e.target){target=e.target}else{if(e.srcElement){target=e.srcElement}}if(target.nodeType==3){target=target.parentNode}while(target&&target.visible==undefined){target=target.parentNode}if(target&&target.foldable){target.style.cursor="pointer"}return true}function unhoverOutline(e){var target;if(!e){var e=window.event}if(e.target){target=e.target}else{if(e.srcElement){target=e.srcElement}}if(target.nodeType==3){target=target.parentNode}while(target&&target.visible==undefined){target=target.parentNode}if(target){target.style.cursor="default"}return true}function stopPropagation(e){if(window.event){window.event.cancelBubble=true}else{if(e){e.cancelBubble=true;e.stopPropagation()}}}function isBlock(elem){var tag=elem.nodeName;return tag=="OL"||tag=="UL"||tag=="P"||tag=="LI"||tag=="TABLE"||tag=="PRE"||tag=="H1"||tag=="H2"||tag=="H3"||tag=="H4"||tag=="H5"||tag=="H6"||tag=="BLOCKQUOTE"||tag=="ADDRESS"}function getElementStyle(elem,IEStyleProp,CSSStyleProp){if(elem.currentStyle){return elem.currentStyle[IEStyleProp]}else{if(window.getComputedStyle){var compStyle=window.getComputedStyle(elem,"");return compStyle.getPropertyValue(CSSStyleProp)}}return""}function createElement(element){if(typeof document.createElementNS!="undefined"){return document.createElementNS("http://www.w3.org/1999/xhtml",element)}if(typeof document.createElement!="undefined"){return document.createElement(element)}return false}function getElementsByTagName(name){if(typeof document.getElementsByTagNameNS!="undefined"){return document.getElementsByTagNameNS("http://www.w3.org/1999/xhtml",name)}if(typeof document.getElementsByTagName!="undefined"){return document.getElementsByTagName(name)}return null}function getSelectedText(){try{if(window.getSelection){return window.getSelection().toString()}if(document.getSelection){return document.getSelection().toString()}if(document.selection){return document.selection.createRange().text}}catch(e){return""}return""};
  </script>
</head>
<body>
<div class="slide cover title">
  <h1 class="title">A guided tour through the bytestring library</h1>
  <p class="author">
Simon Meier
  </p>
  <p class="date">HaskellerZ meetup - January 19th, 2012</p> 
</div>
<div class="slide">

<h1>What this talk covers</h1>
<ul>
<li>The <a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a> library
<ul>
<li>strict and lazy bytestrings</li>
<li>the new bytestring builder (to be included in version <code>0.10.0.0</code>, <a href="https://github.com/meiersi/bytestring">repo</a>, preview <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public">docs</a> )</li>
<li>their use cases, implementation, memory layout, and other stuff that's good to know for writing efficient code</li>
</ul></li>
<li>Side-dishes
<ul>
<li>benchmarking with the <a href="http://hackage.haskell.org/package/criterion"><code>criterion</code></a> library</li>
<li>perhaps some <a href="http://hackage.haskell.org/package/vacuum-cairo"><code>vacuum</code></a> datastructure visualization</li>
</ul></li>
</ul>
<p><a href="https://github.com/meiersi/HaskellerZ/tree/master/meetups/2012%2001%2019%20-%20The%20bytestring%20library">talk repository</a>: sources and <a href="http://johnmacfarlane.net/pandoc/index.html"><code>pandoc</code></a> (what a pleasure to create slides™) config</p>
</div>

<div class="slide">

<h1>Purpose of the bytestring library</h1>
<p>Provide datastructures for computing <em>efficiently</em>, both in time and space, with finite sequences and infinite streams of bytes.</p>
</div>

<div class="slide">

<h1>Why not <code>[Word8]</code>?</h1>
<ul>
<li>Too many indirections: lots of pointer chasing, <a href="http://www.akkadia.org/drepper/cpumemory.pdf">cache misses</a></li>
<li>Too much space overhead (5 machine words for one byte):
<ul>
<li>i.e., a factor 19 (!) overhead on 32-bit systems</li>
<li>i.e., a factor 39 (!) overhead on 64-bit systems</li>
</ul></li>
</ul>
<p>See below for the actual memory representation of <code>[1,2] :: [Word8]</code>. Each box represents one machine word.</p>
<pre><code>  +----------+-----+-----+      +----------+-----+-----+      +---------+
  | (:)-Info | Ptr | Ptr | ---&gt; | (:)-Info | Ptr | Ptr | ---&gt; | []-Info |
  +----------+-----+-----+      +----------+-----+-----+      +---------+
               |                            |
               |                            |
               v                            v
         +-------------+---+          +-------------+---+
         | Word8#-Info | 1 |          | Word8#-Info | 2 |
         +-------------+---+          +-------------+---+
</code></pre>
<p>For more information on the heap layout of the GHC RTS see the <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">GHC commentary</a> or the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm">paper on pointer-tagging</a> by <a href="http://research.microsoft.com/en-us/people/simonmar/">Simmon Marlow</a>, <a href="http://arodriguezyakushev.wordpress.com/publications/">Alexey Rodriguez Yakushev</a>, and <a href="http://research.microsoft.com/en-us/people/simonpj/">Simon Peyton Jones</a>. <a href="http://blog.johantibell.com/">Johan Tibell</a> also posted a good overview of the <a href="http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html">memory overhead of common Haskell types</a>.</p>
</div>

<div class="slide">

<h1>Datastructures supported by the <code>bytestring</code> library</h1>
<ul>
<li>strict bytestrings
<ul>
<li>a chunk of memory</li>
<li>use for finite sequences of bytes (e.g., result of parsing binary data)</li>
</ul></li>
<li>lazy bytestrings
<ul>
<li>a lazy, linked list of chunks of memory</li>
<li>use for long sequences of bytes, possibly generated lazily</li>
</ul></li>
<li>lazy bytestring builder (new in 0.10.0.0, not yet on Hackage, <a href="https://github.com/meiersi/bytestring">repo</a>, <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public">docs</a> )
<ul>
<li>a buffer filling function</li>
<li>supports <em>O(1)</em> <code>append</code> ⇒ efficient composition of short byte sequences</li>
<li>ensures large chunk sizes (important to amortize overhead introduced by chunk boundaries)</li>
<li>use for implementing encodings, i.e., conversion from Haskell values to sequences/streams of bytes</li>
</ul></li>
</ul>
</div>

<div class="slide">

<h1>Strict bytestrings</h1>
<ul>
<li><em>Overhead</em> of a typical bytestring: 9 machine words.</li>
<li>uses pinned memory ⇒ pointers are stable, can be passed to C-APIs</li>
<li><code>ForeignPtr</code>s are versatile: safely reference memory allocated by C-APIs (e.g., <a href="http://hackage.haskell.org/package/mmap">memory mapped files</a>)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- A typical bytestring is of the form</span><br />exampleBS <span class="fu">=</span> <span class="dt">PS</span> (<span class="dt">ForeignPtr</span> addr (<span class="dt">PlainPtr</span> array) len off<br /><br /><span class="co">-- Copied from &quot;bytestring:Data.ByteString.Internal&quot;:</span><br /><span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <span class="dt">PS</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">ForeignPtr</span> <span class="dt">Word8</span>) <span class="co">-- payload</span><br />                     <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>                <span class="co">-- offset</span><br />                     <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>                <span class="co">-- length</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Copied from &quot;base:GHC.ForeignPtr&quot;:</span><br /><span class="kw">data</span> <span class="dt">ForeignPtr</span> a <span class="fu">=</span> <span class="dt">ForeignPtr</span> <span class="dt">Addr</span><span class="fu">#</span> <span class="dt">ForeignPtrContents</span><br /><br /><span class="kw">data</span> <span class="dt">Finalizers</span><br />  <span class="fu">=</span> <span class="dt">NoFinalizers</span><br />  <span class="fu">|</span> <span class="dt">CFinalizers</span><br />  <span class="fu">|</span> <span class="dt">HaskellFinalizers</span><br />    <span class="kw">deriving</span> <span class="kw">Eq</span><br /><br /><span class="kw">data</span> <span class="dt">ForeignPtrContents</span><br />  <span class="fu">=</span> <span class="dt">PlainForeignPtr</span> <span class="fu">!</span>(<span class="dt">IORef</span> (<span class="dt">Finalizers</span>, [<span class="dt">IO</span> ()]))<br />  <span class="fu">|</span> <span class="dt">MallocPtr</span>      (<span class="dt">MutableByteArray</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="fu">!</span>(<span class="dt">IORef</span> (<span class="dt">Finalizers</span>, [<span class="dt">IO</span> ()]))<br />  <span class="fu">|</span> <span class="dt">PlainPtr</span>       (<span class="dt">MutableByteArray</span><span class="fu">#</span> <span class="dt">RealWorld</span>)</code></pre>
</div>

<div class="slide">

<h1>Slicing support</h1>
<ul>
<li>slicing (storing offset and length) allows efficient <code>take</code> and <code>drop</code></li>
<li>may result in memory leaks due to unintended sharing (consider a 5-byte slice of a 32kb chunk of input)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Assume the following qualified import</span><br /><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>      <span class="kw">as</span> <span class="dt">S</span><br /><br /><span class="fu">take</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">S.ByteString</span><br /><span class="fu">take</span> n ps<span class="fu">@</span>(<span class="dt">PS</span> fp off len)<br />    <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> empty<br />    <span class="fu">|</span> n <span class="fu">&gt;=</span> len  <span class="fu">=</span> ps<br />    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">PS</span> fp off n<br /><span class="ot">{-# INLINE take #-}</span></code></pre>
</div>

<div class="slide">

<h1>Implementation tricks</h1>
<ul>
<li>exploit mutable, unboxed datastructure using the <a href="http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html">FFI</a> ⇒ lots of <code>IO</code> code (only in internal code: the official API is <em>simple</em> and <em>pure</em>)</li>
<li>remove abstraction overhead through inlining</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">dropWhile</span><span class="ot"> </span><span class="ot">::</span> (<span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">dropWhile</span> f ps <span class="fu">=</span> unsafeDrop (findIndexOrEnd (<span class="fu">not</span> <span class="fu">.</span> f) ps) ps<br /><span class="ot">{-# INLINE dropWhile #-}</span><br /><br /><span class="co">-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length</span><br /><span class="co">-- of the string if no element is found, rather than Nothing.</span><br /><span class="ot">findIndexOrEnd </span><span class="ot">::</span> (<span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />findIndexOrEnd k (<span class="dt">PS</span> x s l) <span class="fu">=</span> <br />    inlinePerformIO <span class="fu">$</span> withForeignPtr x <span class="fu">$</span> \f <span class="ot">-&gt;</span> go (f <span class="ot">`plusPtr`</span> s) <span class="dv">0</span><br />  <span class="kw">where</span><br />    <span class="dt">STRICT2</span>(go)<br />    go ptr n <span class="fu">|</span> n <span class="fu">&gt;=</span> l    <span class="fu">=</span> <span class="fu">return</span> l<br />             <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">do</span> w <span class="ot">&lt;-</span> peek ptr<br />                              <span class="kw">if</span> k w<br />                                <span class="kw">then</span> <span class="fu">return</span> n<br />                                <span class="kw">else</span> go (ptr <span class="ot">`plusPtr`</span> <span class="dv">1</span>) (n<span class="fu">+</span><span class="dv">1</span>)<br /><span class="ot">{-# INLINE findIndexOrEnd #-}</span><br /><br /><span class="ot">unsafeDrop </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />unsafeDrop n (<span class="dt">PS</span> x s l) <span class="fu">=</span> assert (<span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;=</span> l) <span class="fu">$</span> <span class="dt">PS</span> x (s<span class="fu">+</span>n) (l<span class="fu">-</span>n)<br /><span class="ot">{-# INLINE unsafeDrop #-}</span><br /><br /><span class="ot">inlinePerformIO </span><span class="ot">::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a<br />inlinePerformIO (<span class="dt">IO</span> m) <span class="fu">=</span> <span class="kw">case</span> m realWorld<span class="fu">#</span> <span class="kw">of</span> (<span class="fu">#</span> _, r <span class="fu">#</span>) <span class="ot">-&gt;</span> r<br /><span class="ot">{-# INLINE inlinePerformIO #-}</span></code></pre>
</div>

<div class="slide">

<h1>Creating strict bytestrings</h1>
<ul>
<li>further performance tricks
<ul>
<li>use <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html">bang patterns</a> to remove unnecessary laziness</li>
<li>exploit standard C-routines like <code>memset</code> and <code>memcpy</code>; they are highly optimized</li>
</ul></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- | /O(1)/ The empty 'ByteString'</span><br /><span class="ot">empty </span><span class="ot">::</span> <span class="dt">ByteString</span><br />empty <span class="fu">=</span> <span class="dt">PS</span> nullForeignPtr <span class="dv">0</span> <span class="dv">0</span><br /><br /><span class="co">-- | /O(1)/ Convert a 'Word8' into a 'ByteString'</span><br /><span class="ot">singleton </span><span class="ot">::</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />singleton c <span class="fu">=</span> unsafeCreate <span class="dv">1</span> <span class="fu">$</span> \p <span class="ot">-&gt;</span> poke p c<br /><br /><span class="fu">replicate</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">replicate</span> w c<br />    <span class="fu">|</span> w <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> empty<br />    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsafeCreate w <span class="fu">$</span> \ptr <span class="ot">-&gt;</span><br />                      memset ptr c (<span class="fu">fromIntegral</span> w) <span class="fu">&gt;&gt;</span> <span class="fu">return</span> ()<br /><br /><span class="ot">append </span><span class="ot">::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />append (<span class="dt">PS</span> _   _    <span class="dv">0</span>)    b                  <span class="fu">=</span> b<br />append a                  (<span class="dt">PS</span> _   _    <span class="dv">0</span>)    <span class="fu">=</span> a<br />append (<span class="dt">PS</span> fp1 off1 len1) (<span class="dt">PS</span> fp2 off2 len2) <span class="fu">=</span><br />    unsafeCreate (len1<span class="fu">+</span>len2) <span class="fu">$</span> \destptr1 <span class="ot">-&gt;</span> <span class="kw">do</span><br />      <span class="kw">let</span> destptr2 <span class="fu">=</span> destptr1 <span class="ot">`plusPtr`</span> len1<br />      withForeignPtr fp1 <span class="fu">$</span> \p1 <span class="ot">-&gt;</span> memcpy destptr1 (p1 <span class="ot">`plusPtr`</span> off1) len1<br />      withForeignPtr fp2 <span class="fu">$</span> \p2 <span class="ot">-&gt;</span> memcpy destptr2 (p2 <span class="ot">`plusPtr`</span> off2) len2</code></pre>
</div>

<div class="slide">

<h1>Performance stumbling blocks</h1>
<ul>
<li>repeated <code>append</code> <strong>is slow</strong> (quadratic cost) ⇒ use bytestring builders</li>
<li><code>pack</code>ing and <code>unpack</code>ing from/to <code>[Word8]</code> is <strong>expensive</strong> ⇒ try to avoid this</li>
<li>use cases like (<code>pack . show</code>) are covered by efficient primitives provided by the new bytestring builder
<ul>
<li>e.g., <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-ASCII.html#v:intDec"><code>intDec</code></a> efficently performs a decimal encoding of an <code>Int</code></li>
</ul></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">pack</span><span class="ot"> </span><span class="ot">::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">pack</span> ws <span class="fu">=</span> unsafePackLenBytes (List.length ws) ws<br /><br /><span class="ot">unsafePackLenBytes </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />unsafePackLenBytes len xs0 <span class="fu">=</span><br />    unsafeCreate len <span class="fu">$</span> \p <span class="ot">-&gt;</span> go p xs0<br />  <span class="kw">where</span><br />    go <span class="fu">!</span>_ []     <span class="fu">=</span> <span class="fu">return</span> ()<br />    go <span class="fu">!</span>p (x<span class="fu">:</span>xs) <span class="fu">=</span> poke p x <span class="fu">&gt;&gt;</span> go (p <span class="ot">`plusPtr`</span> <span class="dv">1</span>) xs</code></pre>
</div>

<div class="slide">

<h1>Strict bytestrings summary</h1>
<ul>
<li><p>Pros</p>
<ul>
<li>compact representation of a sequence of bytes</li>
<li>pure, list-like API</li>
<li>support slicing</li>
<li>well-suited for interacting with C-APIs</li>
</ul></li>
<li><p>Cons</p>
<ul>
<li>expensive append</li>
<li>overhead per bytestring: 9 words (this is a lot for short bytestrings)</li>
<li>cannot free unused parts of their underlying chunk of memory</li>
</ul></li>
</ul>
</div>

<div class="slide">

<h1>Lazy bytestrings</h1>
<p>Just a lazy list of strict bytestrings.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <br />       <span class="dt">Empty</span> <br />     <span class="fu">|</span> <span class="dt">Chunk</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">S.ByteString</span> <span class="dt">ByteString</span></code></pre>
<ul>
<li>efficient and compact represention of a pure stream of bytes
<ul>
<li>unreferenced chunks collected by GC</li>
<li>sometimes not expressive enough; errors cannot be reported</li>
</ul></li>
<li>used, <em>but not recommended</em>, for lazy input from the OS
<ul>
<li>lazy reading of chunks ⇒ stream processing with constant memory</li>
<li>works for simple one-shot programs</li>
<li>for long-running programs a better means for dealing with exceptions and scarce resources like file descriptors is required (see libraries like: <a href="http://hackage.haskell.org/package/iteratee"><code>iteratee</code></a>, <a href="http://hackage.haskell.org/package/enumerator"><code>enumerator</code></a>, <a href="http://hackage.haskell.org/package/iterIO"><code>iterIO</code></a>, <a href="http://hackage.haskell.org/package/conduit"><code>conduit</code></a>, etc.)</li>
</ul></li>
<li><p>repeated <code>append</code>s are <strong>expensive</strong> (quadratic cost, too small chunks) ⇒ use lazy bytestring builder</p></li>
<li><p>chunk boundaries incur a performance overhead ⇒ use lazy bytestrings conciously</p></li>
</ul>
</div>

<div class="slide">

<h1>Interlude: difference lists</h1>
<ul>
<li>difference lists are a representation of sequences that supports an <em>O(1)</em> append (at the cost of a loss of sharing)</li>
<li>provided by the <a href="http://hackage.haskell.org/package/dlist"><code>dlist</code></a> library, but often implemented directly</li>
<li>a simple form of the <a href="http://comonad.com/reader/2011/free-monads-for-less/">codensity transformation</a>, explained well in <a href="http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/">this blog post</a></li>
</ul>
</div>

<div class="slide">

<h1>A canonical use case for difference lists</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- strictness annotations</span><br /><span class="ot">{-# LANGUAGE BangPatterns #-}</span><br /><br /><span class="co">-- and a bunch of imports for our later benchmarks</span><br /><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Monoid</span>(<span class="fu">..</span>))<br /><span class="kw">import</span> <span class="dt">Criterion.Main</span> (defaultMain, nf, bgroup, bench)</code></pre>
<p>A canonical use case for difference lists: in-order traversal of trees</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)<br />    <span class="kw">deriving</span>( <span class="kw">Eq</span>, <span class="kw">Ord</span>, <span class="kw">Show</span> )<br /><br /><span class="ot">fullTree </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span><br />fullTree n<br />  <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dt">Leaf</span><br />  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">Node</span> n t' t'<br />  <span class="kw">where</span><br />    t' <span class="fu">=</span> fullTree (n <span class="fu">-</span> <span class="dv">1</span>)<br /><br /><span class="co">-- This version does not scale linearly with the number of nodes </span><br /><span class="co">-- in the tree, as (++) is required to traverse some nodes repeatedly.</span><br /><span class="ot">inorder </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorder <span class="dt">Leaf</span>         <span class="fu">=</span> []<br />inorder (<span class="dt">Node</span> x l r) <span class="fu">=</span> inorder l <span class="fu">++</span> ([x] <span class="fu">++</span> inorder r)<br /><br /><span class="co">-- This version scales linearly, but is hard to read.</span><br /><span class="ot">inorder' </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorder' t <span class="fu">=</span> <br />    go t []<br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         rest <span class="fu">=</span> rest<br />    go (<span class="dt">Node</span> x l r) rest <span class="fu">=</span> go l (x <span class="fu">:</span> go r rest)</code></pre>
<p>Recall the definition of <code>(++)</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(++) </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]<br />(<span class="fu">++</span>) []     ys <span class="fu">=</span> ys<br />(<span class="fu">++</span>) (x<span class="fu">:</span>xs) ys <span class="fu">=</span> x <span class="fu">:</span> xs <span class="fu">++</span> ys</code></pre>
</div>

<div class="slide">

<h1>In-order traversal using difference lists</h1>
<p>A <code>DList</code> is a function that, given the desired rest of the list, returns the complete list.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> a <span class="fu">=</span> <span class="dt">DList</span> {<span class="ot"> runDList </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [a] }<br /><br /><span class="ot">singleton </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a<br />singleton x <span class="fu">=</span> <span class="dt">DList</span> (x<span class="fu">:</span>)<br /><br /><span class="ot">toList </span><span class="ot">::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]<br />toList dl <span class="fu">=</span> runDList dl []<br /><br /><span class="co">-- The standard API for the empty `DList` and concatenation</span><br /><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">DList</span> a) <span class="kw">where</span><br />   mempty            <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">id</span><br />   dl1 <span class="ot">`mappend`</span> dl2 <span class="fu">=</span> <span class="dt">DList</span> (runDList dl1 <span class="fu">.</span> runDList dl2)<br /><br /><span class="co">-- This operator should really make it into base.</span><br /><span class="ot">(&lt;&gt;) </span><span class="ot">::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m<br />(<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> mappend<br /><br /><span class="co">-- much easier to read than `inorder'`</span><br /><span class="ot">inorderDL </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorderDL <span class="fu">=</span><br />    toList <span class="fu">.</span> go<br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         <span class="fu">=</span> mempty<br />    go (<span class="dt">Node</span> x l r) <span class="fu">=</span> go l <span class="fu">&lt;&gt;</span> singleton x <span class="fu">&lt;&gt;</span> go r</code></pre>
<p>Note that <a href="http://hackage.haskell.org/package/semigroups"><code>Semigroups</code></a> are even simpler than <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html"><code>Monoids</code></a>: they provide only the &quot;append&quot; operation. Interestingly, this suffices for many tasks.</p>
</div>

<div class="slide">

<h1>Benchmarking using <code>criterion</code></h1>
<p>In GHCi, the <code>inorderDL</code> version is the slowest, but benchmarks are worth nothing without turning optimizations on ;-)</p>
<p>The <a href="https://github.com/meiersi/HaskellerZ/tree/master/meetups/2012%2001%2019%20-%20The%20bytestring%20library">talk</a> is a literate Haskell file, <a href="http://www.haskell.org/cabal/">cabal</a>ized, and ready to run the following <a href="hackage.haskell.org/package/criterion"><code>criterion</code></a> benchmarks.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">main </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />main <span class="fu">=</span> defaultMain <span class="fu">$</span> <br />  [ bgroup <span class="st">&quot;inorder&quot;</span> <span class="fu">$</span> <span class="fu">concatMap</span> (\mkBench <span class="ot">-&gt;</span> <span class="fu">map</span> mkBench depths) <span class="fu">$</span><br />    [ \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorder&quot;</span>   <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorder   <span class="fu">$</span> (fullTree n) <br />    , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorder'&quot;</span>  <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorder'  <span class="fu">$</span> (fullTree n) <br />    , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorderDL&quot;</span> <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorderDL <span class="fu">$</span> (fullTree n) <br />    ]<br />  , bgroup <span class="st">&quot;size&quot;</span> <span class="fu">$</span> <span class="fu">concatMap</span> (\mkBench <span class="ot">-&gt;</span> <span class="fu">map</span> mkBench depths) <span class="fu">$</span><br />      [ \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;size&quot;</span>      <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf size      <span class="fu">$</span> (fullTree n) <br />      , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;size'&quot;</span>     <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf size'     <span class="fu">$</span> (fullTree n) <br />      ]<br />  ]<br />  <span class="kw">where</span><br />    depths <span class="fu">=</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">13</span>]</code></pre>
<ul>
<li>both <code>inorder'</code> and <code>indorderDL</code> are equally fast and scale linearly</li>
<li><code>inorder</code> does not scale linearly. It is 5 times slower than <code>inorderDL</code> for <code>fullTree 10</code> and 6.6 times slower for <code>fullTree 13</code>.</li>
</ul>
</div>

<div class="slide">

<h1>Side note: removing lazyness</h1>
<p>Note that a similar transform as for <code>inorder'</code> also speeds up the size computation of <code>Tree</code>s. However, here we gain &quot;only&quot; a constant factor 2 speedup. It is due to the removing the unnecessary laziness in the size computation.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">size </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><br />size <span class="dt">Leaf</span>         <span class="fu">=</span> <span class="dv">0</span><br />size (<span class="dt">Node</span> _ l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> size l <span class="fu">+</span> size r<br /><br /><span class="co">-- this version is a factor 2x faster than `size`</span><br /><span class="ot">size' </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><br />size' t0 <span class="fu">=</span> <br />    go t0 <span class="dv">0</span><br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         <span class="fu">!</span>s <span class="fu">=</span> s<br />    go (<span class="dt">Node</span> _ l r) <span class="fu">!</span>s <span class="fu">=</span> go l (go r (s <span class="fu">+</span> <span class="dv">1</span>))</code></pre>
</div>

<div class="slide">

<h1>The lazy bytestring builder</h1>
<ul>
<li>use for implementing encodings (i.e., conversions from Haskell values to sequences of bytes)
<ul>
<li>e.g., HTML, HTTP response, JSON, CSV etc. generation</li>
<li>see this <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder.html">example in the builder documentation</a></li>
</ul></li>
<li>design goals/features
<ul>
<li>provide efficient primitives for encoding standard Haskell values</li>
<li><em>O(1)</em> append ⇒ fast composition of short sequences</li>
<li>ensure large average chunks sizes (for amortizing chunk boundary overhead)</li>
<li>indepent from buffer allocation strategy
<ul>
<li>application can choose appriate strategy (e.g., avoid buffer allocation by executing directly on a <code>Handle</code>'s internal buffer)</li>
</ul></li>
<li>allow full transfer of control over chunk creation
<ul>
<li>insert (large) strict and lazy bytestrings directly</li>
<li>efficiently switch to a different application-specific method for generating lazy bytestrings (e.g., parallel encoding for extra-low latency)</li>
<li>used in zero-copy algorithms for <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-Extras.html#g:8">size-prefixing and chunking of builders</a></li>
</ul></li>
</ul></li>
<li>a redesigned/extended version of the <a href="http://hackage.haskell.org/package/blaze-builder"><code>blaze-builder</code></a> library (which is for example used in <a href="http://www.yesodweb.com/"><code>yesod</code></a>, <a href="http://snapframework.com/"><code>snap</code></a>, and <a href="http://hackage.haskell.org/package/aeson"><code>aeson</code></a>)</li>
</ul>
</div>

<div class="slide">

<h1>The types underlying the lazy bytestring builder</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BufferRange</span> <span class="fu">=</span> <span class="dt">BufferRange</span> <br />       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)  <span class="co">-- First byte of range</span><br />       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)  <span class="co">-- First byte /after/ range</span><br /><br /><span class="co">-- a lazy bytestring difference-list annotated with its size</span><br /><span class="kw">data</span> <span class="dt">SizedChunks</span> <span class="fu">=</span><br />         <span class="dt">SizedChunks</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int64</span> (<span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">L.ByteString</span>)<br /><br /><span class="co">-- a buffer-range-filling function</span><br /><span class="kw">type</span> <span class="dt">BuildStep</span> a <span class="fu">=</span> <span class="dt">BufferRange</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">BuildSignal</span> a)<br /><br /><span class="co">-- the result of filling a buffer-range</span><br /><span class="kw">data</span> <span class="dt">BuildSignal</span> a <span class="fu">=</span><br />    <span class="dt">Done</span> <br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />                     a                <span class="co">-- value computed (for Put monad)</span><br /><br />  <span class="fu">|</span> <span class="dt">BufferFull</span>                        <span class="co">-- signal a full buffer</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>             <span class="co">-- minimal size for next buffer</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />                     <span class="fu">!</span>(<span class="dt">BuildStep</span> a)   <span class="co">-- next buildstep to call</span><br /><br />  <span class="fu">|</span> <span class="dt">InsertChunks</span>                      <span class="co">-- transfer control over chunk generation</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">SizedChunks</span>     <span class="co">-- produced chunks</span><br />                     <span class="fu">!</span>(<span class="dt">Maybe</span> <span class="dt">Buffer</span>)  <span class="co">-- partial buffer to be filled further</span><br />                     <span class="fu">!</span>(<span class="dt">BuildStep</span> a)   <span class="co">-- next buildstep to call</span><br /><br /><span class="co">-- the lazy bytestring builder: a difference-list of buffer filling functions</span><br /><span class="kw">newtype</span> <span class="dt">Builder</span> <span class="fu">=</span> <span class="dt">Builder</span> (forall r<span class="fu">.</span> <span class="dt">BuildStep</span> r <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r)<br /><br /><span class="co">-- the Put monad for computing a value while filling a buffer</span><br /><span class="co">-- (e.g., a checksum over the generated chunks or an error report)</span><br /><span class="kw">newtype</span> <span class="dt">Put</span> a <span class="fu">=</span> <span class="dt">Put</span> {<span class="ot"> unPut </span><span class="ot">::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r) <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r }</code></pre>
</div>

<div class="slide">

<h1>How to construct primitive lazy bytestring builders</h1>
<ul>
<li>use the <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html">types and combinators</a> provided for
<ul>
<li><a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html#g:1"><em>fixed-size encodings</em></a>, which always result in a sequence of bytes of a predetermined, fixed length</li>
<li><a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html#g:4"><em>bounded-size encodings</em></a>, which always result in a sequence of bytes that is no larger than a predetermined bound</li>
</ul></li>
<li>combinators allow to fuse escaping with character encoding (e.g., combined escaping and UTF-8 encoding of HTML, JSON, or Haskell strings)</li>
<li>rewriting rules fuse buffer-free checks of consecutive primitive builders</li>
<li>useful for wrapping C-implementions like <a href="http://hackage.haskell.org/package/double-conversion">V8's decimal encodings for IEEE floats</a></li>
</ul>
</div>

<div class="slide">

<h1>An example of a bounded-size encoding: <code>int8Dec</code></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- | Decimal encoding of an 'Int8'.</span><br /><span class="ot">{-# INLINE int8Dec #-}</span><br /><span class="ot">int8Dec </span><span class="ot">::</span> <span class="dt">BoundedEncoding</span> <span class="dt">Int8</span><br />int8Dec <span class="fu">=</span> boundedEncoding <span class="dv">4</span> <span class="fu">$</span> c_int_dec <span class="fu">.</span> <span class="fu">fromIntegral</span><br /><br /><span class="co">-- | An encoding that always results in sequence of bytes that is no longer</span><br /><span class="co">-- than a pre-determined bound.</span><br /><span class="kw">data</span> <span class="dt">BoundedEncoding</span> a <span class="fu">=</span> <span class="dt">BE</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> (a <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>))<br /><br /><span class="co">-- | Encode a value with a 'BoundedEncoding'.</span><br /><span class="ot">{-# INLINE[1] encodeWithB #-}</span><br /><span class="ot">encodeWithB </span><span class="ot">::</span> <span class="dt">BoundedEncoding</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Builder</span>)<br />encodeWithB (<span class="dt">BE</span> bound io) x <span class="fu">=</span><br />    <span class="co">-- It is important to avoid recursive 'BuildStep's where possible, as</span><br />    <span class="co">-- their closure allocation is expensive. Using 'ensureFree' allows the</span><br />    <span class="co">-- 'step' to assume that at least 'sizeBound w' free space is available.</span><br />    ensureFree (bound) <span class="ot">`mappend`</span> builder step<br />  <span class="kw">where</span><br />    step k (<span class="dt">BufferRange</span> op ope) <span class="fu">=</span> <span class="kw">do</span><br />        op' <span class="ot">&lt;-</span> io x op<br />        <span class="kw">let</span> <span class="fu">!</span>br' <span class="fu">=</span> <span class="dt">BufferRange</span> op' ope<br />        k br'<br /><br /><span class="co">-- | Ensure that there are at least 'n' free bytes for the following 'Builder'.</span><br /><span class="ot">{-# INLINE ensureFree #-}</span><br /><span class="ot">ensureFree </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span><br />ensureFree minFree <span class="fu">=</span><br />    builder step<br />  <span class="kw">where</span><br />    step k br<span class="fu">@</span>(<span class="dt">BufferRange</span> op ope)<br />      <span class="fu">|</span> ope <span class="ot">`minusPtr`</span> op <span class="fu">&lt;</span> minFree <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> bufferFull minFree op k<br />      <span class="fu">|</span> <span class="fu">otherwise</span>                   <span class="fu">=</span> k br<br /><br /><span class="co">-- fast decimal encoding of `CInt`s</span><br />foreign <span class="kw">import</span> ccall unsafe <span class="st">&quot;static _hs_bytestring_int_dec&quot;</span> c_int_dec<br /><span class="ot">    </span><span class="ot">::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>)</code></pre>
</div>

<div class="slide">

<h1>HTML escaping fused with UTF-8 encoding</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Builder.BasicEncoding</span>  <span class="kw">as</span> <span class="dt">E</span><br /><span class="kw">import</span>           <span class="dt">Data.ByteString.Lazy.Builder.BasicEncoding</span><br />                 ( ifB, fromF, (<span class="fu">&gt;*&lt;</span>), (<span class="fu">&gt;$&lt;</span>) )<br /><br /><span class="ot">{-# INLINE charUtf8HtmlEscaped #-}</span><br /><span class="ot">charUtf8HtmlEscaped </span><span class="ot">::</span> <span class="dt">E.BoundedEncoding</span> <span class="dt">Char</span><br />charUtf8HtmlEscaped <span class="fu">=</span><br />    ifB (<span class="fu">&gt;</span>  <span class="ch">'&gt;'</span> ) E.charUtf8 <span class="fu">$</span>  <span class="co">-- '&gt;' is the largest escaped 'Char'</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&lt;'</span> ) (fixed4 (<span class="ch">'&amp;'</span>,(<span class="ch">'l'</span>,(<span class="ch">'t'</span>,<span class="ch">';'</span>)))) <span class="fu">$</span>        <span class="co">-- &amp;lt;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&gt;'</span> ) (fixed4 (<span class="ch">'&amp;'</span>,(<span class="ch">'g'</span>,(<span class="ch">'t'</span>,<span class="ch">';'</span>)))) <span class="fu">$</span>        <span class="co">-- &amp;gt;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&amp;'</span> ) (fixed5 (<span class="ch">'&amp;'</span>,(<span class="ch">'a'</span>,(<span class="ch">'m'</span>,(<span class="ch">'p'</span>,<span class="ch">';'</span>))))) <span class="fu">$</span>  <span class="co">-- &amp;amp;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&quot;'</span> ) (fixed5 (<span class="ch">'&amp;'</span>,(<span class="ch">'#'</span>,(<span class="ch">'3'</span>,(<span class="ch">'4'</span>,<span class="ch">';'</span>))))) <span class="fu">$</span>  <span class="co">-- &amp;#34;</span><br />    (fromF E.char7)             <span class="co">-- fallback for remaining 'Char's</span><br />  <span class="kw">where</span><br />    <span class="ot">{-# INLINE fixed4 #-}</span><br />    fixed4 x <span class="fu">=</span> fromF <span class="fu">$</span> <span class="fu">const</span> x <span class="fu">&gt;$&lt;</span><br />      E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7<br /><br />    <span class="ot">{-# INLINE fixed5 #-}</span><br />    fixed5 x <span class="fu">=</span> fromF <span class="fu">$</span> <span class="fu">const</span> x <span class="fu">&gt;$&lt;</span><br />      E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7</code></pre>
<ul>
<li><p>The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting <code>BoundedEncoding</code> can be computed at compile time.</p></li>
<li><p>The resulting code checks first, if there are 5 bytes free in the current buffer. If not, then it requests a new buffer. Otherwise, the character is encoded. Note the writing of the escaped characters is compiled down to the corresponding sequence of fixed <code>mov</code> operations. Nice.</p></li>
</ul>
</div>

<div class="slide">

<h1>Some missing pieces in our library infrastructure</h1>
<ul>
<li>Use cases not covered well by any existing Haskell library
<ul>
<li>representing short sequences of bytes (slicing and <code>ForeignPtr</code> overhead too expensive)</li>
<li>very efficiently creating short bytestrings, i.e., strict bytestring builders
<ul>
<li>typical use-case: remote procedure calls</li>
<li>may support more efficient length-prefixing for Google's <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html">protocol buffer encoding</a></li>
</ul></li>
</ul></li>
<li>Use cases covered by other libraries
<ul>
<li>parsing binary data: use <a href="http://hackage.haskell.org/package/attoparsec"><code>attoparsec</code></a></li>
<li>representing sequences of Unicode characters: use <a href="http://hackage.haskell.org/package/text"><code>text</code></a></li>
<li>thanks to <a href="http://www.serpentine.com/blog/">Bryan O'Sullivan</a> for creating these libraries</li>
<li>binary serialization: use <a href="http://hackage.haskell.org/package/binary"><code>binary</code></a> (might be redesigned to make use of new bytestring builder features)</li>
</ul></li>
</ul>
</div>

<div class="slide">

<h1>Conclusions</h1>
<ul>
<li>use bytestrings to represent binary data</li>
<li>use the lazy bytestring builder to implement encodings</li>
<li>use <code>pack</code>, <code>unpack</code>, and <code>append</code> conciously (when writing performance critical code)</li>
<li>ensure that the chunks of lazy bytestrings are large enough to amortize the chunk boundary overhead</li>
<li><em>for writing very efficient code</em>: understand the memory layout and the cost of the operations of your types</li>
</ul>
<p><strong>Enjoy Haskell</strong>: enabling the construction of pure <em>and</em> efficient API's is just beautiful ☺</p>
</div>

<div class="slide">

<h1>Thanks...</h1>
<p>...for listening.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="dt">Control.Monad.Has.Questions</span><span class="fu">&gt;</span> <span class="fu">?</span></code></pre>
</div>
</body>
</html>
