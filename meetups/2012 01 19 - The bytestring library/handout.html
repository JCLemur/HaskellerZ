<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Simon Meier" />
  <meta name="date" content="HaskellerZ meetup - January 19th, 2012" />
  <title>A guided tour through the bytestring library</title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
  </style>
</head>
<body>
<h1 class="title">A guided tour through the bytestring library</h1>
<div id="TOC">
<ul>
<li><a href="#what-this-talk-covers">What this talk covers</a></li>
<li><a href="#purpose-of-the-bytestring-library">Purpose of the bytestring library</a></li>
<li><a href="#why-not-word8">Why not <code>[Word8]</code>?</a></li>
<li><a href="#datastructures-supported-by-the-bytestring-library">Datastructures supported by the <code>bytestring</code> library</a></li>
<li><a href="#strict-bytestrings">Strict bytestrings</a></li>
<li><a href="#slicing-support">Slicing support</a></li>
<li><a href="#implementation-tricks">Implementation tricks</a></li>
<li><a href="#creating-strict-bytestrings">Creating strict bytestrings</a></li>
<li><a href="#performance-stumbling-blocks">Performance stumbling blocks</a></li>
<li><a href="#strict-bytestrings-summary">Strict bytestrings summary</a></li>
<li><a href="#lazy-bytestrings">Lazy bytestrings</a></li>
<li><a href="#interlude-difference-lists">Interlude: difference lists</a></li>
<li><a href="#a-canonical-use-case-for-difference-lists">A canonical use case for difference lists</a></li>
<li><a href="#in-order-traversal-using-difference-lists">In-order traversal using difference lists</a></li>
<li><a href="#benchmarking-using-criterion">Benchmarking using <code>criterion</code></a></li>
<li><a href="#side-note-removing-lazyness">Side note: removing lazyness</a></li>
<li><a href="#the-lazy-bytestring-builder">The lazy bytestring builder</a></li>
<li><a href="#the-types-underlying-the-lazy-bytestring-builder">The types underlying the lazy bytestring builder</a></li>
<li><a href="#how-to-construct-primitive-lazy-bytestring-builders">How to construct primitive lazy bytestring builders</a></li>
<li><a href="#an-example-of-a-bounded-size-encoding-int8dec">An example of a bounded-size encoding: <code>int8Dec</code></a></li>
<li><a href="#html-escaping-fused-with-utf-8-encoding">HTML escaping fused with UTF–8 encoding</a></li>
<li><a href="#some-missing-pieces-in-our-library-infrastructure">Some missing pieces in our library infrastructure</a></li>
<li><a href="#conclusions">Conclusions</a></li>
<li><a href="#thanks...">Thanks…</a></li>
</ul>
</div>
<h1 id="what-this-talk-covers"><a href="#TOC">What this talk covers</a></h1>
<ul>
<li>The <a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a> library
<ul>
<li>strict and lazy bytestrings</li>
<li>the new bytestring builder (to be included in version <code>0.10.0.0</code>, <a href="https://github.com/meiersi/bytestring">repo</a>, preview <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public">docs</a> )</li>
<li>their use cases, implementation, memory layout, and other stuff that’s good to know for writing efficient code</li>
</ul></li>
<li>Side-dishes
<ul>
<li>benchmarking with the <a href="http://hackage.haskell.org/package/criterion"><code>criterion</code></a> library</li>
<li>perhaps some <a href="http://hackage.haskell.org/package/vacuum-cairo"><code>vacuum</code></a> datastructure visualization</li>
</ul></li>
</ul>
<p><a href="https://github.com/meiersi/HaskellerZ/tree/master/meetups/2012%2001%2019%20-%20The%20bytestring%20library">talk repository</a>: sources and <a href="http://johnmacfarlane.net/pandoc/index.html"><code>pandoc</code></a> (what a pleasure to create slides™) config</p>
<h1 id="purpose-of-the-bytestring-library"><a href="#TOC">Purpose of the bytestring library</a></h1>
<p>Provide datastructures for computing <em>efficiently</em>, both in time and space, with finite sequences and infinite streams of bytes.</p>
<h1 id="why-not-word8"><a href="#TOC">Why not <code>[Word8]</code>?</a></h1>
<ul>
<li>Too many indirections: lots of pointer chasing, <a href="http://www.akkadia.org/drepper/cpumemory.pdf">cache misses</a></li>
<li>Too much space overhead (5 machine words for one byte):
<ul>
<li>i.e., a factor 19 (!) overhead on 32-bit systems</li>
<li>i.e., a factor 39 (!) overhead on 64-bit systems</li>
</ul></li>
</ul>
<p>See below for the actual memory representation of <code>[1,2] :: [Word8]</code>. Each box represents one machine word.</p>
<pre><code>  +----------+-----+-----+      +----------+-----+-----+      +---------+
  | (:)-Info | Ptr | Ptr | ---&gt; | (:)-Info | Ptr | Ptr | ---&gt; | []-Info |
  +----------+-----+-----+      +----------+-----+-----+      +---------+
               |                            |
               |                            |
               v                            v
         +-------------+---+          +-------------+---+
         | Word8#-Info | 1 |          | Word8#-Info | 2 |
         +-------------+---+          +-------------+---+
</code></pre>
<p>For more information on the heap layout of the GHC RTS see the <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">GHC commentary</a> or the <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm">paper on pointer-tagging</a> by <a href="http://research.microsoft.com/en-us/people/simonmar/">Simmon Marlow</a>, <a href="http://arodriguezyakushev.wordpress.com/publications/">Alexey Rodriguez Yakushev</a>, and <a href="http://research.microsoft.com/en-us/people/simonpj/">Simon Peyton Jones</a>. <a href="http://blog.johantibell.com/">Johan Tibell</a> also posted a good overview of the <a href="http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html">memory overhead of common Haskell types</a>.</p>
<h1 id="datastructures-supported-by-the-bytestring-library"><a href="#TOC">Datastructures supported by the <code>bytestring</code> library</a></h1>
<ul>
<li>strict bytestrings
<ul>
<li>a chunk of memory</li>
<li>use for finite sequences of bytes (e.g., result of parsing binary data)</li>
</ul></li>
<li>lazy bytestrings
<ul>
<li>a lazy, linked list of chunks of memory</li>
<li>use for long sequences of bytes, possibly generated lazily</li>
</ul></li>
<li>lazy bytestring builder (new in 0.10.0.0, not yet on Hackage, <a href="https://github.com/meiersi/bytestring">repo</a>, <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public">docs</a> )
<ul>
<li>a buffer filling function</li>
<li>supports <em>O(1)</em> <code>append</code> ⇒ efficient composition of short byte sequences</li>
<li>ensures large chunk sizes (important to amortize overhead introduced by chunk boundaries)</li>
<li>use for implementing encodings, i.e., conversion from Haskell values to sequences/streams of bytes</li>
</ul></li>
</ul>
<h1 id="strict-bytestrings"><a href="#TOC">Strict bytestrings</a></h1>
<ul>
<li><em>Overhead</em> of a typical bytestring: 9 machine words.</li>
<li>uses pinned memory ⇒ pointers are stable, can be passed to C-APIs</li>
<li><code>ForeignPtr</code>s are versatile: safely reference memory allocated by C-APIs (e.g., <a href="http://hackage.haskell.org/package/mmap">memory mapped files</a>)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- A typical bytestring is of the form</span><br />exampleBS <span class="fu">=</span> <span class="dt">PS</span> (<span class="dt">ForeignPtr</span> addr (<span class="dt">PlainPtr</span> array) len off<br /><br /><span class="co">-- Copied from &quot;bytestring:Data.ByteString.Internal&quot;:</span><br /><span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <span class="dt">PS</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">ForeignPtr</span> <span class="dt">Word8</span>) <span class="co">-- payload</span><br />                     <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>                <span class="co">-- offset</span><br />                     <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>                <span class="co">-- length</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Copied from &quot;base:GHC.ForeignPtr&quot;:</span><br /><span class="kw">data</span> <span class="dt">ForeignPtr</span> a <span class="fu">=</span> <span class="dt">ForeignPtr</span> <span class="dt">Addr</span><span class="fu">#</span> <span class="dt">ForeignPtrContents</span><br /><br /><span class="kw">data</span> <span class="dt">Finalizers</span><br />  <span class="fu">=</span> <span class="dt">NoFinalizers</span><br />  <span class="fu">|</span> <span class="dt">CFinalizers</span><br />  <span class="fu">|</span> <span class="dt">HaskellFinalizers</span><br />    <span class="kw">deriving</span> <span class="kw">Eq</span><br /><br /><span class="kw">data</span> <span class="dt">ForeignPtrContents</span><br />  <span class="fu">=</span> <span class="dt">PlainForeignPtr</span> <span class="fu">!</span>(<span class="dt">IORef</span> (<span class="dt">Finalizers</span>, [<span class="dt">IO</span> ()]))<br />  <span class="fu">|</span> <span class="dt">MallocPtr</span>      (<span class="dt">MutableByteArray</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="fu">!</span>(<span class="dt">IORef</span> (<span class="dt">Finalizers</span>, [<span class="dt">IO</span> ()]))<br />  <span class="fu">|</span> <span class="dt">PlainPtr</span>       (<span class="dt">MutableByteArray</span><span class="fu">#</span> <span class="dt">RealWorld</span>)</code></pre>
<h1 id="slicing-support"><a href="#TOC">Slicing support</a></h1>
<ul>
<li>slicing (storing offset and length) allows efficient <code>take</code> and <code>drop</code></li>
<li>may result in memory leaks due to unintended sharing (consider a 5-byte slice of a 32kb chunk of input)</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Assume the following qualified import</span><br /><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>      <span class="kw">as</span> <span class="dt">S</span><br /><br /><span class="fu">take</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">S.ByteString</span><br /><span class="fu">take</span> n ps<span class="fu">@</span>(<span class="dt">PS</span> fp off len)<br />    <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> empty<br />    <span class="fu">|</span> n <span class="fu">&gt;=</span> len  <span class="fu">=</span> ps<br />    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">PS</span> fp off n<br /><span class="ot">{-# INLINE take #-}</span></code></pre>
<h1 id="implementation-tricks"><a href="#TOC">Implementation tricks</a></h1>
<ul>
<li>exploit mutable, unboxed datastructure using the <a href="http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html">FFI</a> ⇒ lots of <code>IO</code> code (only in internal code: the official API is <em>simple</em> and <em>pure</em>)</li>
<li>remove abstraction overhead through inlining</li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">dropWhile</span><span class="ot"> </span><span class="ot">::</span> (<span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">dropWhile</span> f ps <span class="fu">=</span> unsafeDrop (findIndexOrEnd (<span class="fu">not</span> <span class="fu">.</span> f) ps) ps<br /><span class="ot">{-# INLINE dropWhile #-}</span><br /><br /><span class="co">-- | 'findIndexOrEnd' is a variant of findIndex, that returns the length</span><br /><span class="co">-- of the string if no element is found, rather than Nothing.</span><br /><span class="ot">findIndexOrEnd </span><span class="ot">::</span> (<span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><br />findIndexOrEnd k (<span class="dt">PS</span> x s l) <span class="fu">=</span> <br />    inlinePerformIO <span class="fu">$</span> withForeignPtr x <span class="fu">$</span> \f <span class="ot">-&gt;</span> go (f <span class="ot">`plusPtr`</span> s) <span class="dv">0</span><br />  <span class="kw">where</span><br />    <span class="dt">STRICT2</span>(go)<br />    go ptr n <span class="fu">|</span> n <span class="fu">&gt;=</span> l    <span class="fu">=</span> <span class="fu">return</span> l<br />             <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="kw">do</span> w <span class="ot">&lt;-</span> peek ptr<br />                              <span class="kw">if</span> k w<br />                                <span class="kw">then</span> <span class="fu">return</span> n<br />                                <span class="kw">else</span> go (ptr <span class="ot">`plusPtr`</span> <span class="dv">1</span>) (n<span class="fu">+</span><span class="dv">1</span>)<br /><span class="ot">{-# INLINE findIndexOrEnd #-}</span><br /><br /><span class="ot">unsafeDrop </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />unsafeDrop n (<span class="dt">PS</span> x s l) <span class="fu">=</span> assert (<span class="dv">0</span> <span class="fu">&lt;=</span> n <span class="fu">&amp;&amp;</span> n <span class="fu">&lt;=</span> l) <span class="fu">$</span> <span class="dt">PS</span> x (s<span class="fu">+</span>n) (l<span class="fu">-</span>n)<br /><span class="ot">{-# INLINE unsafeDrop #-}</span><br /><br /><span class="ot">inlinePerformIO </span><span class="ot">::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a<br />inlinePerformIO (<span class="dt">IO</span> m) <span class="fu">=</span> <span class="kw">case</span> m realWorld<span class="fu">#</span> <span class="kw">of</span> (<span class="fu">#</span> _, r <span class="fu">#</span>) <span class="ot">-&gt;</span> r<br /><span class="ot">{-# INLINE inlinePerformIO #-}</span></code></pre>
<h1 id="creating-strict-bytestrings"><a href="#TOC">Creating strict bytestrings</a></h1>
<ul>
<li>further performance tricks
<ul>
<li>use <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html">bang patterns</a> to remove unnecessary laziness</li>
<li>exploit standard C-routines like <code>memset</code> and <code>memcpy</code>; they are highly optimized</li>
</ul></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- | /O(1)/ The empty 'ByteString'</span><br /><span class="ot">empty </span><span class="ot">::</span> <span class="dt">ByteString</span><br />empty <span class="fu">=</span> <span class="dt">PS</span> nullForeignPtr <span class="dv">0</span> <span class="dv">0</span><br /><br /><span class="co">-- | /O(1)/ Convert a 'Word8' into a 'ByteString'</span><br /><span class="ot">singleton </span><span class="ot">::</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />singleton c <span class="fu">=</span> unsafeCreate <span class="dv">1</span> <span class="fu">$</span> \p <span class="ot">-&gt;</span> poke p c<br /><br /><span class="fu">replicate</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">replicate</span> w c<br />    <span class="fu">|</span> w <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> empty<br />    <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> unsafeCreate w <span class="fu">$</span> \ptr <span class="ot">-&gt;</span><br />                      memset ptr c (<span class="fu">fromIntegral</span> w) <span class="fu">&gt;&gt;</span> <span class="fu">return</span> ()<br /><br /><span class="ot">append </span><span class="ot">::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />append (<span class="dt">PS</span> _   _    <span class="dv">0</span>)    b                  <span class="fu">=</span> b<br />append a                  (<span class="dt">PS</span> _   _    <span class="dv">0</span>)    <span class="fu">=</span> a<br />append (<span class="dt">PS</span> fp1 off1 len1) (<span class="dt">PS</span> fp2 off2 len2) <span class="fu">=</span><br />    unsafeCreate (len1<span class="fu">+</span>len2) <span class="fu">$</span> \destptr1 <span class="ot">-&gt;</span> <span class="kw">do</span><br />      <span class="kw">let</span> destptr2 <span class="fu">=</span> destptr1 <span class="ot">`plusPtr`</span> len1<br />      withForeignPtr fp1 <span class="fu">$</span> \p1 <span class="ot">-&gt;</span> memcpy destptr1 (p1 <span class="ot">`plusPtr`</span> off1) len1<br />      withForeignPtr fp2 <span class="fu">$</span> \p2 <span class="ot">-&gt;</span> memcpy destptr2 (p2 <span class="ot">`plusPtr`</span> off2) len2</code></pre>
<h1 id="performance-stumbling-blocks"><a href="#TOC">Performance stumbling blocks</a></h1>
<ul>
<li>repeated <code>append</code> <strong>is slow</strong> (quadratic cost) ⇒ use bytestring builders</li>
<li><code>pack</code>ing and <code>unpack</code>ing from/to <code>[Word8]</code> is <strong>expensive</strong> ⇒ try to avoid this</li>
<li>use cases like (<code>pack . show</code>) are covered by efficient primitives provided by the new bytestring builder
<ul>
<li>e.g., <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-ASCII.html#v:intDec"><code>intDec</code></a> efficently performs a decimal encoding of an <code>Int</code></li>
</ul></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">pack</span><span class="ot"> </span><span class="ot">::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br /><span class="fu">pack</span> ws <span class="fu">=</span> unsafePackLenBytes (List.length ws) ws<br /><br /><span class="ot">unsafePackLenBytes </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">ByteString</span><br />unsafePackLenBytes len xs0 <span class="fu">=</span><br />    unsafeCreate len <span class="fu">$</span> \p <span class="ot">-&gt;</span> go p xs0<br />  <span class="kw">where</span><br />    go <span class="fu">!</span>_ []     <span class="fu">=</span> <span class="fu">return</span> ()<br />    go <span class="fu">!</span>p (x<span class="fu">:</span>xs) <span class="fu">=</span> poke p x <span class="fu">&gt;&gt;</span> go (p <span class="ot">`plusPtr`</span> <span class="dv">1</span>) xs</code></pre>
<h1 id="strict-bytestrings-summary"><a href="#TOC">Strict bytestrings summary</a></h1>
<ul>
<li><p>Pros</p>
<ul>
<li>compact representation of a sequence of bytes</li>
<li>pure, list-like API</li>
<li>support slicing</li>
<li>well-suited for interacting with C-APIs</li>
</ul></li>
<li><p>Cons</p>
<ul>
<li>expensive append</li>
<li>overhead per bytestring: 9 words (this is a lot for short bytestrings)</li>
<li>cannot free unused parts of their underlying chunk of memory</li>
</ul></li>
</ul>
<h1 id="lazy-bytestrings"><a href="#TOC">Lazy bytestrings</a></h1>
<p>Just a lazy list of strict bytestrings.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ByteString</span> <span class="fu">=</span> <br />       <span class="dt">Empty</span> <br />     <span class="fu">|</span> <span class="dt">Chunk</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">S.ByteString</span> <span class="dt">ByteString</span></code></pre>
<ul>
<li>efficient and compact represention of a pure stream of bytes
<ul>
<li>unreferenced chunks collected by GC</li>
<li>sometimes not expressive enough; errors cannot be reported</li>
</ul></li>
<li>used, <em>but not recommended</em>, for lazy input from the OS
<ul>
<li>lazy reading of chunks ⇒ stream processing with constant memory</li>
<li>works for simple one-shot programs</li>
<li>for long-running programs a better means for dealing with exceptions and scarce resources like file descriptors is required (see libraries like: <a href="http://hackage.haskell.org/package/iteratee"><code>iteratee</code></a>, <a href="http://hackage.haskell.org/package/enumerator"><code>enumerator</code></a>, <a href="http://hackage.haskell.org/package/iterIO"><code>iterIO</code></a>, <a href="http://hackage.haskell.org/package/conduit"><code>conduit</code></a>, etc.)</li>
</ul></li>
<li><p>repeated <code>append</code>s are <strong>expensive</strong> (quadratic cost, too small chunks) ⇒ use lazy bytestring builder</p></li>
<li><p>chunk boundaries incur a performance overhead ⇒ use lazy bytestrings conciously</p></li>
</ul>
<h1 id="interlude-difference-lists"><a href="#TOC">Interlude: difference lists</a></h1>
<ul>
<li>difference lists are a representation of sequences that supports an <em>O(1)</em> append (at the cost of a loss of sharing)</li>
<li>provided by the <a href="http://hackage.haskell.org/package/dlist"><code>dlist</code></a> library, but often implemented directly</li>
<li>a simple form of the <a href="http://comonad.com/reader/2011/free-monads-for-less/">codensity transformation</a>, explained well in <a href="http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/">this blog post</a></li>
</ul>
<h1 id="a-canonical-use-case-for-difference-lists"><a href="#TOC">A canonical use case for difference lists</a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- strictness annotations</span><br /><span class="ot">{-# LANGUAGE BangPatterns #-}</span><br /><br /><span class="co">-- and a bunch of imports for our later benchmarks</span><br /><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Monoid</span>(<span class="fu">..</span>))<br /><span class="kw">import</span> <span class="dt">Criterion.Main</span> (defaultMain, nf, bgroup, bench)</code></pre>
<p>A canonical use case for difference lists: in-order traversal of trees</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)<br />    <span class="kw">deriving</span>( <span class="kw">Eq</span>, <span class="kw">Ord</span>, <span class="kw">Show</span> )<br /><br /><span class="ot">fullTree </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span><br />fullTree n<br />  <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span>    <span class="fu">=</span> <span class="dt">Leaf</span><br />  <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> <span class="dt">Node</span> n t' t'<br />  <span class="kw">where</span><br />    t' <span class="fu">=</span> fullTree (n <span class="fu">-</span> <span class="dv">1</span>)<br /><br /><span class="co">-- This version does not scale linearly with the number of nodes </span><br /><span class="co">-- in the tree, as (++) is required to traverse some nodes repeatedly.</span><br /><span class="ot">inorder </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorder <span class="dt">Leaf</span>         <span class="fu">=</span> []<br />inorder (<span class="dt">Node</span> x l r) <span class="fu">=</span> inorder l <span class="fu">++</span> ([x] <span class="fu">++</span> inorder r)<br /><br /><span class="co">-- This version scales linearly, but is hard to read.</span><br /><span class="ot">inorder' </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorder' t <span class="fu">=</span> <br />    go t []<br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         rest <span class="fu">=</span> rest<br />    go (<span class="dt">Node</span> x l r) rest <span class="fu">=</span> go l (x <span class="fu">:</span> go r rest)</code></pre>
<p>Recall the definition of <code>(++)</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(++) </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]<br />(<span class="fu">++</span>) []     ys <span class="fu">=</span> ys<br />(<span class="fu">++</span>) (x<span class="fu">:</span>xs) ys <span class="fu">=</span> x <span class="fu">:</span> xs <span class="fu">++</span> ys</code></pre>
<h1 id="in-order-traversal-using-difference-lists"><a href="#TOC">In-order traversal using difference lists</a></h1>
<p>A <code>DList</code> is a function that, given the desired rest of the list, returns the complete list.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> a <span class="fu">=</span> <span class="dt">DList</span> {<span class="ot"> runDList </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [a] }<br /><br /><span class="ot">singleton </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">DList</span> a<br />singleton x <span class="fu">=</span> <span class="dt">DList</span> (x<span class="fu">:</span>)<br /><br /><span class="ot">toList </span><span class="ot">::</span> <span class="dt">DList</span> a <span class="ot">-&gt;</span> [a]<br />toList dl <span class="fu">=</span> runDList dl []<br /><br /><span class="co">-- The standard API for the empty `DList` and concatenation</span><br /><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">DList</span> a) <span class="kw">where</span><br />   mempty            <span class="fu">=</span> <span class="dt">DList</span> <span class="fu">id</span><br />   dl1 <span class="ot">`mappend`</span> dl2 <span class="fu">=</span> <span class="dt">DList</span> (runDList dl1 <span class="fu">.</span> runDList dl2)<br /><br /><span class="co">-- This operator should really make it into base.</span><br /><span class="ot">(&lt;&gt;) </span><span class="ot">::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m<br />(<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> mappend<br /><br /><span class="co">-- much easier to read than `inorder'`</span><br /><span class="ot">inorderDL </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]<br />inorderDL <span class="fu">=</span><br />    toList <span class="fu">.</span> go<br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         <span class="fu">=</span> mempty<br />    go (<span class="dt">Node</span> x l r) <span class="fu">=</span> go l <span class="fu">&lt;&gt;</span> singleton x <span class="fu">&lt;&gt;</span> go r</code></pre>
<p>Note that <a href="http://hackage.haskell.org/package/semigroups"><code>Semigroups</code></a> are even simpler than <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Monoid.html"><code>Monoids</code></a>: they provide only the “append” operation. Interestingly, this suffices for many tasks.</p>
<h1 id="benchmarking-using-criterion"><a href="#TOC">Benchmarking using <code>criterion</code></a></h1>
<p>In GHCi, the <code>inorderDL</code> version is the slowest, but benchmarks are worth nothing without turning optimizations on ;-)</p>
<p>The <a href="https://github.com/meiersi/HaskellerZ/tree/master/meetups/2012%2001%2019%20-%20The%20bytestring%20library">talk</a> is a literate Haskell file, <a href="http://www.haskell.org/cabal/">cabal</a>ized, and ready to run the following <a href="hackage.haskell.org/package/criterion"><code>criterion</code></a> benchmarks.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">main </span><span class="ot">::</span> <span class="dt">IO</span> ()<br />main <span class="fu">=</span> defaultMain <span class="fu">$</span> <br />  [ bgroup <span class="st">&quot;inorder&quot;</span> <span class="fu">$</span> <span class="fu">concatMap</span> (\mkBench <span class="ot">-&gt;</span> <span class="fu">map</span> mkBench depths) <span class="fu">$</span><br />    [ \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorder&quot;</span>   <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorder   <span class="fu">$</span> (fullTree n) <br />    , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorder'&quot;</span>  <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorder'  <span class="fu">$</span> (fullTree n) <br />    , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;inorderDL&quot;</span> <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf inorderDL <span class="fu">$</span> (fullTree n) <br />    ]<br />  , bgroup <span class="st">&quot;size&quot;</span> <span class="fu">$</span> <span class="fu">concatMap</span> (\mkBench <span class="ot">-&gt;</span> <span class="fu">map</span> mkBench depths) <span class="fu">$</span><br />      [ \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;size&quot;</span>      <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf size      <span class="fu">$</span> (fullTree n) <br />      , \n <span class="ot">-&gt;</span> bench (<span class="st">&quot;size'&quot;</span>     <span class="fu">++</span> <span class="fu">show</span> n) <span class="fu">$</span> nf size'     <span class="fu">$</span> (fullTree n) <br />      ]<br />  ]<br />  <span class="kw">where</span><br />    depths <span class="fu">=</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">13</span>]</code></pre>
<ul>
<li>both <code>inorder'</code> and <code>indorderDL</code> are equally fast and scale linearly</li>
<li><code>inorder</code> does not scale linearly. It is 5 times slower than <code>inorderDL</code> for <code>fullTree 10</code> and 6.6 times slower for <code>fullTree 13</code>.</li>
</ul>
<h1 id="side-note-removing-lazyness"><a href="#TOC">Side note: removing lazyness</a></h1>
<p>Note that a similar transform as for <code>inorder'</code> also speeds up the size computation of <code>Tree</code>s. However, here we gain “only” a constant factor 2 speedup. It is due to the removing the unnecessary laziness in the size computation.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">size </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><br />size <span class="dt">Leaf</span>         <span class="fu">=</span> <span class="dv">0</span><br />size (<span class="dt">Node</span> _ l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> size l <span class="fu">+</span> size r<br /><br /><span class="co">-- this version is a factor 2x faster than `size`</span><br /><span class="ot">size' </span><span class="ot">::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><br />size' t0 <span class="fu">=</span> <br />    go t0 <span class="dv">0</span><br />  <span class="kw">where</span><br />    go <span class="dt">Leaf</span>         <span class="fu">!</span>s <span class="fu">=</span> s<br />    go (<span class="dt">Node</span> _ l r) <span class="fu">!</span>s <span class="fu">=</span> go l (go r (s <span class="fu">+</span> <span class="dv">1</span>))</code></pre>
<h1 id="the-lazy-bytestring-builder"><a href="#TOC">The lazy bytestring builder</a></h1>
<ul>
<li>use for implementing encodings (i.e., conversions from Haskell values to sequences of bytes)
<ul>
<li>e.g., HTML, HTTP response, JSON, CSV etc. generation</li>
<li>see this <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder.html">example in the builder documentation</a></li>
</ul></li>
<li>design goals/features
<ul>
<li>provide efficient primitives for encoding standard Haskell values</li>
<li><em>O(1)</em> append ⇒ fast composition of short sequences</li>
<li>ensure large average chunks sizes (for amortizing chunk boundary overhead)</li>
<li>indepent from buffer allocation strategy
<ul>
<li>application can choose appriate strategy (e.g., avoid buffer allocation by executing directly on a <code>Handle</code>’s internal buffer)</li>
</ul></li>
<li>allow full transfer of control over chunk creation
<ul>
<li>insert (large) strict and lazy bytestrings directly</li>
<li>efficiently switch to a different application-specific method for generating lazy bytestrings (e.g., parallel encoding for extra-low latency)</li>
<li>used in zero-copy algorithms for <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-Extras.html#g:8">size-prefixing and chunking of builders</a></li>
</ul></li>
</ul></li>
<li>a redesigned/extended version of the <a href="http://hackage.haskell.org/package/blaze-builder"><code>blaze-builder</code></a> library (which is for example used in <a href="http://www.yesodweb.com/"><code>yesod</code></a>, <a href="http://snapframework.com/"><code>snap</code></a>, and <a href="http://hackage.haskell.org/package/aeson"><code>aeson</code></a>)</li>
</ul>
<h1 id="the-types-underlying-the-lazy-bytestring-builder"><a href="#TOC">The types underlying the lazy bytestring builder</a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BufferRange</span> <span class="fu">=</span> <span class="dt">BufferRange</span> <br />       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)  <span class="co">-- First byte of range</span><br />       <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)  <span class="co">-- First byte /after/ range</span><br /><br /><span class="co">-- a lazy bytestring difference-list annotated with its size</span><br /><span class="kw">data</span> <span class="dt">SizedChunks</span> <span class="fu">=</span><br />         <span class="dt">SizedChunks</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int64</span> (<span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">L.ByteString</span>)<br /><br /><span class="co">-- a buffer-range-filling function</span><br /><span class="kw">type</span> <span class="dt">BuildStep</span> a <span class="fu">=</span> <span class="dt">BufferRange</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">BuildSignal</span> a)<br /><br /><span class="co">-- the result of filling a buffer-range</span><br /><span class="kw">data</span> <span class="dt">BuildSignal</span> a <span class="fu">=</span><br />    <span class="dt">Done</span> <br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />                     a                <span class="co">-- value computed (for Put monad)</span><br /><br />  <span class="fu">|</span> <span class="dt">BufferFull</span>                        <span class="co">-- signal a full buffer</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span>             <span class="co">-- minimal size for next buffer</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />                     <span class="fu">!</span>(<span class="dt">BuildStep</span> a)   <span class="co">-- next buildstep to call</span><br /><br />  <span class="fu">|</span> <span class="dt">InsertChunks</span>                      <span class="co">-- transfer control over chunk generation</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span>(<span class="dt">Ptr</span> <span class="dt">Word8</span>)     <span class="co">-- pointer to first byte after data</span><br />      <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">SizedChunks</span>     <span class="co">-- produced chunks</span><br />                     <span class="fu">!</span>(<span class="dt">Maybe</span> <span class="dt">Buffer</span>)  <span class="co">-- partial buffer to be filled further</span><br />                     <span class="fu">!</span>(<span class="dt">BuildStep</span> a)   <span class="co">-- next buildstep to call</span><br /><br /><span class="co">-- the lazy bytestring builder: a difference-list of buffer filling functions</span><br /><span class="kw">newtype</span> <span class="dt">Builder</span> <span class="fu">=</span> <span class="dt">Builder</span> (forall r<span class="fu">.</span> <span class="dt">BuildStep</span> r <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r)<br /><br /><span class="co">-- the Put monad for computing a value while filling a buffer</span><br /><span class="co">-- (e.g., a checksum over the generated chunks or an error report)</span><br /><span class="kw">newtype</span> <span class="dt">Put</span> a <span class="fu">=</span> <span class="dt">Put</span> {<span class="ot"> unPut </span><span class="ot">::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r) <span class="ot">-&gt;</span> <span class="dt">BuildStep</span> r }</code></pre>
<h1 id="how-to-construct-primitive-lazy-bytestring-builders"><a href="#TOC">How to construct primitive lazy bytestring builders</a></h1>
<ul>
<li>use the <a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html">types and combinators</a> provided for
<ul>
<li><a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html#g:1"><em>fixed-size encodings</em></a>, which always result in a sequence of bytes of a predetermined, fixed length</li>
<li><a href="http://people.inf.ethz.ch/meiersi/downloads/private/bytestring-0.10.0.0-public/Data-ByteString-Lazy-Builder-BasicEncoding.html#g:4"><em>bounded-size encodings</em></a>, which always result in a sequence of bytes that is no larger than a predetermined bound</li>
</ul></li>
<li>combinators allow to fuse escaping with character encoding (e.g., combined escaping and UTF–8 encoding of HTML, JSON, or Haskell strings)</li>
<li>rewriting rules fuse buffer-free checks of consecutive primitive builders</li>
<li>useful for wrapping C-implementions like <a href="http://hackage.haskell.org/package/double-conversion">V8’s decimal encodings for IEEE floats</a></li>
</ul>
<h1 id="an-example-of-a-bounded-size-encoding-int8dec"><a href="#TOC">An example of a bounded-size encoding: <code>int8Dec</code></a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- | Decimal encoding of an 'Int8'.</span><br /><span class="ot">{-# INLINE int8Dec #-}</span><br /><span class="ot">int8Dec </span><span class="ot">::</span> <span class="dt">BoundedEncoding</span> <span class="dt">Int8</span><br />int8Dec <span class="fu">=</span> boundedEncoding <span class="dv">4</span> <span class="fu">$</span> c_int_dec <span class="fu">.</span> <span class="fu">fromIntegral</span><br /><br /><span class="co">-- | An encoding that always results in sequence of bytes that is no longer</span><br /><span class="co">-- than a pre-determined bound.</span><br /><span class="kw">data</span> <span class="dt">BoundedEncoding</span> a <span class="fu">=</span> <span class="dt">BE</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Int</span> (a <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>))<br /><br /><span class="co">-- | Encode a value with a 'BoundedEncoding'.</span><br /><span class="ot">{-# INLINE[1] encodeWithB #-}</span><br /><span class="ot">encodeWithB </span><span class="ot">::</span> <span class="dt">BoundedEncoding</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Builder</span>)<br />encodeWithB (<span class="dt">BE</span> bound io) x <span class="fu">=</span><br />    <span class="co">-- It is important to avoid recursive 'BuildStep's where possible, as</span><br />    <span class="co">-- their closure allocation is expensive. Using 'ensureFree' allows the</span><br />    <span class="co">-- 'step' to assume that at least 'sizeBound w' free space is available.</span><br />    ensureFree (bound) <span class="ot">`mappend`</span> builder step<br />  <span class="kw">where</span><br />    step k (<span class="dt">BufferRange</span> op ope) <span class="fu">=</span> <span class="kw">do</span><br />        op' <span class="ot">&lt;-</span> io x op<br />        <span class="kw">let</span> <span class="fu">!</span>br' <span class="fu">=</span> <span class="dt">BufferRange</span> op' ope<br />        k br'<br /><br /><span class="co">-- | Ensure that there are at least 'n' free bytes for the following 'Builder'.</span><br /><span class="ot">{-# INLINE ensureFree #-}</span><br /><span class="ot">ensureFree </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span><br />ensureFree minFree <span class="fu">=</span><br />    builder step<br />  <span class="kw">where</span><br />    step k br<span class="fu">@</span>(<span class="dt">BufferRange</span> op ope)<br />      <span class="fu">|</span> ope <span class="ot">`minusPtr`</span> op <span class="fu">&lt;</span> minFree <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span> bufferFull minFree op k<br />      <span class="fu">|</span> <span class="fu">otherwise</span>                   <span class="fu">=</span> k br<br /><br /><span class="co">-- fast decimal encoding of `CInt`s</span><br />foreign <span class="kw">import</span> ccall unsafe <span class="st">&quot;static _hs_bytestring_int_dec&quot;</span> c_int_dec<br /><span class="ot">    </span><span class="ot">::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> <span class="dt">Word8</span>)</code></pre>
<h1 id="html-escaping-fused-with-utf-8-encoding"><a href="#TOC">HTML escaping fused with UTF–8 encoding</a></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Builder.BasicEncoding</span>  <span class="kw">as</span> <span class="dt">E</span><br /><span class="kw">import</span>           <span class="dt">Data.ByteString.Lazy.Builder.BasicEncoding</span><br />                 ( ifB, fromF, (<span class="fu">&gt;*&lt;</span>), (<span class="fu">&gt;$&lt;</span>) )<br /><br /><span class="ot">{-# INLINE charUtf8HtmlEscaped #-}</span><br /><span class="ot">charUtf8HtmlEscaped </span><span class="ot">::</span> <span class="dt">E.BoundedEncoding</span> <span class="dt">Char</span><br />charUtf8HtmlEscaped <span class="fu">=</span><br />    ifB (<span class="fu">&gt;</span>  <span class="ch">'&gt;'</span> ) E.charUtf8 <span class="fu">$</span>  <span class="co">-- '&gt;' is the largest escaped 'Char'</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&lt;'</span> ) (fixed4 (<span class="ch">'&amp;'</span>,(<span class="ch">'l'</span>,(<span class="ch">'t'</span>,<span class="ch">';'</span>)))) <span class="fu">$</span>        <span class="co">-- &amp;lt;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&gt;'</span> ) (fixed4 (<span class="ch">'&amp;'</span>,(<span class="ch">'g'</span>,(<span class="ch">'t'</span>,<span class="ch">';'</span>)))) <span class="fu">$</span>        <span class="co">-- &amp;gt;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&amp;'</span> ) (fixed5 (<span class="ch">'&amp;'</span>,(<span class="ch">'a'</span>,(<span class="ch">'m'</span>,(<span class="ch">'p'</span>,<span class="ch">';'</span>))))) <span class="fu">$</span>  <span class="co">-- &amp;amp;</span><br />    ifB (<span class="fu">==</span> <span class="ch">'&quot;'</span> ) (fixed5 (<span class="ch">'&amp;'</span>,(<span class="ch">'#'</span>,(<span class="ch">'3'</span>,(<span class="ch">'4'</span>,<span class="ch">';'</span>))))) <span class="fu">$</span>  <span class="co">-- &amp;#34;</span><br />    (fromF E.char7)             <span class="co">-- fallback for remaining 'Char's</span><br />  <span class="kw">where</span><br />    <span class="ot">{-# INLINE fixed4 #-}</span><br />    fixed4 x <span class="fu">=</span> fromF <span class="fu">$</span> <span class="fu">const</span> x <span class="fu">&gt;$&lt;</span><br />      E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7<br /><br />    <span class="ot">{-# INLINE fixed5 #-}</span><br />    fixed5 x <span class="fu">=</span> fromF <span class="fu">$</span> <span class="fu">const</span> x <span class="fu">&gt;$&lt;</span><br />      E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7 <span class="fu">&gt;*&lt;</span> E.char7</code></pre>
<ul>
<li><p>The slightly awkward syntax is because the combinators are written such that the size-bound of the resulting <code>BoundedEncoding</code> can be computed at compile time.</p></li>
<li><p>The resulting code checks first, if there are 5 bytes free in the current buffer. If not, then it requests a new buffer. Otherwise, the character is encoded. Note the writing of the escaped characters is compiled down to the corresponding sequence of fixed <code>mov</code> operations. Nice.</p></li>
</ul>
<h1 id="some-missing-pieces-in-our-library-infrastructure"><a href="#TOC">Some missing pieces in our library infrastructure</a></h1>
<ul>
<li>Use cases not covered well by any existing Haskell library
<ul>
<li>representing short sequences of bytes (slicing and <code>ForeignPtr</code> overhead too expensive)</li>
<li>very efficiently creating short bytestrings, i.e., strict bytestring builders
<ul>
<li>typical use-case: remote procedure calls</li>
<li>may support more efficient length-prefixing for Google’s <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html">protocol buffer encoding</a></li>
</ul></li>
</ul></li>
<li>Use cases covered by other libraries
<ul>
<li>parsing binary data: use <a href="http://hackage.haskell.org/package/attoparsec"><code>attoparsec</code></a></li>
<li>representing sequences of Unicode characters: use <a href="http://hackage.haskell.org/package/text"><code>text</code></a></li>
<li>thanks to <a href="http://www.serpentine.com/blog/">Bryan O’Sullivan</a> for creating these libraries</li>
<li>binary serialization: use <a href="http://hackage.haskell.org/package/binary"><code>binary</code></a> (might be redesigned to make use of new bytestring builder features)</li>
</ul></li>
</ul>
<h1 id="conclusions"><a href="#TOC">Conclusions</a></h1>
<ul>
<li>use bytestrings to represent binary data</li>
<li>use the lazy bytestring builder to implement encodings</li>
<li>use <code>pack</code>, <code>unpack</code>, and <code>append</code> conciously (when writing performance critical code)</li>
<li>ensure that the chunks of lazy bytestrings are large enough to amortize the chunk boundary overhead</li>
<li><em>for writing very efficient code</em>: understand the memory layout and the cost of the operations of your types</li>
</ul>
<p><strong>Enjoy Haskell</strong>: enabling the construction of pure <em>and</em> efficient API’s is just beautiful ☺</p>
<h1 id="thanks..."><a href="#TOC">Thanks…</a></h1>
<p>…for listening.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="dt">Control.Monad.Has.Questions</span><span class="fu">&gt;</span> <span class="fu">?</span></code></pre>
</body>
</html>
